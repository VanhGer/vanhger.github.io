<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hiimvanhg</title>
    <link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Mở rộng Blockchain (Phần 2)</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Mở rộng Blockchain (Phần 2)" />
<meta name="author" content="vanhg" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Trong bài viết hôm nay, mình sẽ giới thiệu đến mọi người một kĩ thuật giúp tăng tốc độ các Tx trong mạng blockchain. Đó là Rollups." />
<meta property="og:description" content="Trong bài viết hôm nay, mình sẽ giới thiệu đến mọi người một kĩ thuật giúp tăng tốc độ các Tx trong mạng blockchain. Đó là Rollups." />
<link rel="canonical" href="http://localhost:4000/blog/2023/08/19/scaling-the-blockchain-p2" />
<meta property="og:url" content="http://localhost:4000/blog/2023/08/19/scaling-the-blockchain-p2" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-19T00:00:00+07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Mở rộng Blockchain (Phần 2)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"vanhg"},"dateModified":"2023-08-19T00:00:00+07:00","datePublished":"2023-08-19T00:00:00+07:00","description":"Trong bài viết hôm nay, mình sẽ giới thiệu đến mọi người một kĩ thuật giúp tăng tốc độ các Tx trong mạng blockchain. Đó là Rollups.","headline":"Mở rộng Blockchain (Phần 2)","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2023/08/19/scaling-the-blockchain-p2"},"url":"http://localhost:4000/blog/2023/08/19/scaling-the-blockchain-p2"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <div class="header">
  <div class = "tab_container">
      
        <a href="/" 
        
        class = "tab_btn">
        Home
        </a>
      
        <a href="/about.html" 
        
        class = "tab_btn">
        About
        </a>
      
        <a href="/blog.html" 
        
        class = "tab_btn">
        Blog
        </a>
      
        <a href="/staff.html" 
        
        class = "tab_btn">
        Staff
        </a>
      
  </div>
</div>

    <div class = "default_content">
        <h1 class = "post_title">Mở rộng Blockchain (Phần 2)</h1>
        <p class = "post_detail">
            vanhg - 19 Aug 2023 
        </p>
        <div class = "img_container">
            <img src =  class = "post_img">
        </div>
        <div class = "post_content">
          <p>Trong bài viết hôm nay, mình sẽ giới thiệu đến mọi người một kĩ thuật giúp tăng tốc độ các Tx trong mạng blockchain. Đó là Rollups.</p>

<h2 id="ý-tưởng">Ý tưởng</h2>
<p>Trong layer-1 của blockchain như Ethereum chứa world state. Khi một giao dịch được đưa vào, world state sẽ bị thay đổi. Từ đây, ý tưởng cơ bản của Rollup là hợp hàng trăm Tx lại thành một Tx duy nhất, từ đó giúp tăng tốc độ lên khoảng 100 lần.</p>

<p>Ta có hình minh hoạ như sau:</p>

<p>Từ đây, ta gọi Rollup state là L2, để phân biệt với L1 (layer-1 của blockchain). <br />
Rollup contract ở L1 sẽ giữ các tài sản và Merkle state root của các Rollup account. Rollup state chỉ bao gồm số dư của các Rollup account.</p>

<p>/// hình ảnh</p>

<h2 id="hiệu-năng">Hiệu năng</h2>
<p><strong> Chuyển tiền trong 1 Rollup </strong></p>
<ul>
  <li>Chuyển tiền trong 1 Rollup (L2 -&gt; L2) rất dễ dàng. Các coordinators chỉ cần cập nhập lại Merkle Root của Rollup Contract trên L1 là xong.</li>
</ul>

<p><strong> Chuyển tiền từ funds đến Rollup </strong></p>
<ul>
  <li>Chuyển tiền từ funds đến Rollup (L1 -&gt; L2) thì chậm và đắt. Lý do vì cần phải update các state trong L1, số dư trong contract và cả trong Rollup và cập nhập lại Root của contract đó.</li>
</ul>

<p><strong> Chuyển tiền ra khỏi Rollup </strong></p>
<ul>
  <li>Chuyển tiền ra khỏi Rollup cần phí gas thêm từ L1 trong quá trình chuyển vì cần post nhiều dữ liệu.</li>
</ul>

<p><strong> Chuyển tiền từ 2 Rollup </strong></p>
<ul>
  <li>Nếu chuyển tiền từ 2 Rollup (L2 -&gt; L2’) mà qua L1 thì sẽ rất đắt, nhưng nếu qua 1 cầu trực tiếp L2 &lt;=&gt; L2 thì sẽ rẻ.</li>
</ul>

<h3 id="chạy-contract-trong-rollup">Chạy contract trong Rollup</h3>
<p>Khi contract chạy trong Rollup (Ví dụ Uniswap), thì việc tương tác với contract đó sẽ rẩt rẻ cho người dùng. <br />
<strong> Coordinator </strong> duy trì trạng thái của tất cả contracts trong hệ thống Rollup:</p>
<ul>
  <li>Nó cập nhập Uniswap Merkle Leaf mỗi khi 1 Tx nào đó đến Uniswap</li>
  <li>Ghi update cho Rollup state root trên L1.</li>
</ul>

<p>Rollup có chức năng giống Ethereum, nhưng không có cơ chế đồng thuận vì nó dựa vào L1 để chứng thực trạng thái hiện tại.</p>

<h2 id="các-vấn-đề">Các vấn đề</h2>
<p><strong> Vấn đề 1 </strong>: Điều gì xảy ra nếu Coordinator không trung thực. Nó có thể lấy hết tiền trong Rollup hoặc tạo các giao dịch giả.</p>

<p><strong> Vấn đề 2 </strong>: Nếu Coordinator ngừng cung cấp dịch vụ ? Làm sao để lấy lại trạng thái Rollup để đưa cho Coordinator mới.</p>

<h2 id="các-phương-án-giải-quyết">Các phương án giải quyết</h2>
<h3 id="vấn-đề-1-coordinator-không-trung-thực">Vấn đề 1: Coordinator không trung thực</h3>
<p>Coordinator không thể lấy tiền từ Rollup users, vì L1 sẽ xác minh update trạng thái của Rollup bằng cách kiểm tra xem tất cả các Tx có valid và được ký hợp lệ bởi người dùng hay không. <br />
Để làm điều này một cách rẻ, có thể có các cách tiếp cận sau:</p>

<h4 id="validity-proofs-còn-gọi-là-zk-rollup">Validity Proofs (còn gọi là zk-Rollup)</h4>
<p>Khi coordinator gửi updated root và Tx List cho L1, nó cần gửi kèm theo một SNARK proof cho valid Tx để chứng minh tập hàng trăm các Tx này là hợp lệ. <br />
<strong> SNARK proof </strong> là loại proof ngắn và nhanh để xác minh, từ đó giúp việc xác minh trên L1 trở nên rẻ. (với sự giúp đỡ của EVM)  <br />
Bao gồm:</p>
<ul>
  <li>Public statement:   (old state root,  new state root,  Tx list)</li>
  <li>Witness: (state trước - sau của những tài khoản bị thay đổi, bằng chứng Merkle, chữ kí của user)</li>
  <li>SNARK proof sẽ chứng minh rằng:
    <ul>
      <li>Tất cả chữ ký trên đều valid</li>
      <li>Tất cả bằng chứng Merkle đều valid</li>
      <li>Trạng thái sau = trạng thái trước + Tx.</li>
    </ul>
  </li>
</ul>

<p><strong> zkEVM </strong>  <br />
Khi một contract (Uniswap) chạy trong Rollup:</p>
<ul>
  <li>Coordinator sẽ tạo 1 SNARK proof về việc thực hiện đúng 1 chương trình EVM. Đó gọi là zkEVM.</li>
  <li>Tạo bằng chứng thì sẽ yêu cầu rất cao về tính toán nhưng khi xác minh thì lại rất nhanh.</li>
</ul>

<p>Có 2 chức năng của zkEVM là:</p>
<ul>
  <li>Chứng minh EVM bytecode chạy đúng</li>
  <li>Biên dịch Solidity to SNARK-friendly circuit.</li>
</ul>

<p><strong> Kết quả </strong></p>
<ul>
  <li>Rollup contract đảm bảo coordinator không thể gian lận và sẽ chấp nhận các update nếu có proof phù hợp</li>
  <li>Ai cũng có thể làm coordinator nếu có đủ sức mạnh tính toán</li>
</ul>

<h4 id="fraud-proof-còn-gọi-là-optimistic-rollup">Fraud proof (còn gọi là Optimistic Rollup)</h4>
<ul>
  <li>Coordinator sẽ stake 1 khoản vào L1 Rollup Contract</li>
  <li>Coordinator sẽ đưa updated root lên L1 mà không cần bằng chứng</li>
  <li>Nếu update không valid, trong vòng 7 ngày ai cũng có thể chứng minh điều này bằng việc gửi fraud proof.</li>
  <li>Nếu fraud proof là đúng, coordinator sẽ bị Slash, ngược lại người gửi proof sẽ tốn phí.</li>
</ul>

<p>Để chứng minh Fraud đến Rollup contract trong L1, ta sẽ sử dụng Binary Search. <br />
Việc Coordinator và Người gửi Proof (A) tạo ra state(n) và state(n’) khác nhau buộc L1 cần kiểm tra xem ai mới là người đúng. Do đó, sử dụng Merkle tree và tìm kiếm nhị phân, với việc chia đôi từ state(n/2), state(n/4)… có thể dễ dàng tìm được xem state nào bị sai sau Log2(n) round.</p>

<p>Tuy nhiên, cách này gặp 1 số khó khăn như:</p>
<ul>
  <li>Giao dịch chỉ giải quyết sau 7 ngày (Sau khi hết hạn gian lận)</li>
  <li>Khi 1 bằng chứng Fraud được chấp nhận, các Tx sau phải được gửi lại</li>
</ul>

<p><strong> Kết quả </strong></p>
<ul>
  <li>Có thể dễ dàng đưa smartcontract vào optimistic Rollup</li>
  <li>Thông lượng Tx cao: ~ 4000Tx / s</li>
  <li>Ai cũng có thể làm coordinator và verifier</li>
  <li>Giải quyết giao dịch chậm 7 ngày.</li>
</ul>

<h3 id="vấn-đề-2-coordinator-ngừng-cung-cấp-dịch-vụ">Vấn đề 2: Coordinator ngừng cung cấp dịch vụ</h3>
<p>Cần tạo Coordinator mới, nhưng lại cần trạng thái mới nhất của Rollup.</p>

<p>Ta thấy, Rollup state có thể phục hồi từ dữ liệu trong L1 bằng việc đọc các msg và re-excecute Tx. Nhưng việc này sẽ rất đắt vì tương tác nhiều trên L1 và cần nhiều dữ liệu.</p>

<p>Để giảm Tx fees:</p>
<ul>
  <li>Lưu L2 state root trong L1</li>
  <li>Lưu Tx data với Data Availability Committee (DAC):
    <ul>
      <li>Gồm tập hợp các node tin cậy giữ cho data available</li>
      <li>Rẻ hơn lưu ở L1</li>
      <li>L1 chấp nhận update khi và chỉ khi tất cả các node trong DAC đều kí. Từ đó giúp đảm bảo các member trong DAC đều chấp nhập dữ liệu Tx.</li>
    </ul>
  </li>
  <li>Tạo 1 coordinator mới phụ thuộc vào tính khả dụng của DAC</li>
</ul>

<h4 id="validium">Validium</h4>
<p>1 L2 sử dụng DAC để lưu trữ và Validity proof (SNARKs):</p>
<ul>
  <li>Phù hợp cho tài sản giá trị thấp</li>
  <li>Chỉ các thành viên DAC mới thấy được dữ liệu</li>
</ul>

<h4 id="điều-gì-xảy-ra-nếu-coordinator-từ-chối-1-tx">Điều gì xảy ra nếu Coordinator từ chối 1 Tx</h4>
<ul>
  <li>Người tạo có thể post Tx trực tiếp lên L1 Rollup contract.</li>
  <li>L1 Rollup contract chỉ chấp nhận update khi mà update có cả Tx trên. Từ đó dẫn đến toàn bộ Rollup bị đóng băng.</li>
</ul>

<h2 id="lời-kết">Lời kết</h2>
<p>Ở trên đây là các cách được áp dụng để tăng tốc độ Tx trong blockchain.</p>

        </div>
        
    </div>
  </body>
  <footer>
    
  </footer>
</html>  