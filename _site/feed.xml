<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-21T23:38:10+07:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Bitcoin Scripts và Ví</title><link href="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet" rel="alternate" type="text/html" title="Bitcoin Scripts và Ví" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/bitcoin-scripts-and-wallet</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet"><![CDATA[<p>Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.</p>

<h3 id="một-số-lưu-ý">Một số lưu ý</h3>
<ul>
  <li>Các Tx sau khi thêm vào khối sẽ không thể bị xoá, do đó khi Tx nhầm thì sẽ bị khoá hoặc mất tiền.</li>
  <li>Các TxID là độc nhất, vì Input của chúng là độc nhất. Có trường hợp ngoại lệ là các Coinbase vì chúng không có input. Do đó có thể có trùng TxID. Vì vậy, người ta thường thêm Block Height và mỗi ScriptPk của coinbase.</li>
</ul>

<h2 id="ví-dụ-về-các-loại-bitcoin-scripts">Ví dụ về các loại Bitcoin Scripts</h2>
<h3 id="bảo-vệ-tài-sản-với-co-signatory">Bảo vệ tài sản với co-signatory</h3>
<p>addr = 2 - of - 2 (PkA, PkS) với PkS là của custody server.</p>

<h3 id="escrow-service">Escrow Service</h3>
<p>Giả định: A muốn mua balo từ B với giá 0.1 BTC, nhưng A chỉ có thể trả tiền khi balo đến, và không thể không trả. Do vậy, addr có dạng: 2-of-3 (PkA, PkB, PkJ).</p>

<p>Cách vận hành:</p>
<ul>
  <li>A thông báo cho B rằng muốn mua balo với giá 0.1 BTC</li>
  <li>A post 1 Tx 0.11 BTC đến addr trên (0.01BTC để đảm bảo A sẽ trả tiền cho B).</li>
  <li>B khi thấy Tx, gửi balo cho A</li>
  <li>Khi A nhận, gửi SigA trong Tx trên cho B</li>
  <li>B sẽ sử dụng SigA và SigB để lấy số tiền mà A gửi lên Addr.</li>
</ul>

<p>Nếu vi phạm xảy ra:</p>
<ul>
  <li>B không đưa balo, A sẽ lấy lại tiền với sự trợ giúp của Judge (PkJ).</li>
  <li>A không đưa SigA, B sẽ lấy tiền với sự giúp đỡ của Judge, A mất thêm 0.01BTC.</li>
</ul>

<h2 id="ví">Ví</h2>
<p>Ví giúp user tạo ra các cặp Pk- Sk, tạo ra và xác minh các Tx, đưa ra số dư mà user có.</p>

<h3 id="giúp-đơn-giản-hoá-xác-minh-thanh-toán">Giúp đơn giản hoá xác minh thanh toán</h3>
<p>Để xác minh một thanh toán đã thực hiện, ví thường tải các block headers. Sau đó, ví gửi lên server danh sách các địa chỉ mà ví đang nắm giữ. Sau đó, server sẽ gửi về ví các Tx liên quan đến địa chỉ và Merkle Proof của Tx đó. Từ đó giúp ví hiển thị đúng số dư và xác minh Tx.</p>

<h3 id="vấn-dề">Vấn dề</h3>
<ul>
  <li>Để giải quyết được yếu tố bảo mật, blockheader sẽ được tải từ 10 servers khác nhau hoặc từ 1 nodes tin cậy.</li>
  <li>Remote server có thể kiểm tra xem addr gửi lên có thuộc về ví hay không.</li>
</ul>

<h3 id="các-loại-ví">Các loại ví</h3>
<h4 id="hot-wallet">Hot wallet</h4>
<ul>
  <li>Dạng ví điện tử có kết nối Internet, có nhiều chức năng như lưu trữ, gửi nhận Tx, tokens,…</li>
  <li>Có thể truy cập từ các thiết bị Internet như máy tính, điện thoại,..</li>
  <li>Có thể bị hack hoặc xâm nhập bởi các hacker.</li>
</ul>

<h3 id="cold-wallet">Cold wallet</h3>
<ul>
  <li>Không cho phép kết nối Internet.</li>
  <li>Có thiết bị riêng cho cold wallet, thiết bị này phải được khởi động bất cứ khi nào sử dụng và người dùng phải sao chép vật lý dữ liệu từ online device sang offline và ngược lại.</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Có nhiều loại Bitcoin Script khác như CrossChain,… được sử dụng rất phổ biến ở hiện tại.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.]]></summary></entry><entry><title type="html">Cơ bản về đồng thuận</title><link href="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus" rel="alternate" type="text/html" title="Cơ bản về đồng thuận" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus"><![CDATA[<p>Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. 
Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.</p>

<h2 id="tác-hại-của-adversary">Tác hại của Adversary</h2>
<p>Có thể gây:</p>
<ul>
  <li>Lỗi crash: Nếu các nodes này không gửi và nhận các msg (message)</li>
  <li>Lỗi bỏ sót: Nếu các nodes này chọn hoặc bỏ qua các msg</li>
  <li>Lỗi Byzantine: Các node sai có thể đi lệch khỏi giao thức.</li>
</ul>

<p>Có 2 loại adversary</p>
<ul>
  <li>Static: phá huỷ node mà nó chọn trước khi bắt đầu giao thức.</li>
  <li>Adaptive: có thể phá huỷ các node khi giao thức xảy ra.
<br />
Giới hạn sức mạnh của adversary là số node:  f. Ví dụ: f &lt; n/2, f &lt; n/3.</li>
</ul>

<h2 id="các-nodes-giao-tiếp-với-nhau">Các nodes giao tiếp với nhau</h2>
<p>Các nodes gửi các tin nhắn (message) cho nhau trong giao thức. Giả sử một node adversary đang điều khiển việc gửi tin nhắn:</p>
<ul>
  <li>Trong một mạng đồng bộ: Adversary phải chuyển tin nhắn bất kì trong thời gian Δ giây (Δ đã biết).</li>
  <li>Trong mạng không đồng bộ: Adversary có thể hoãn msg trong 1 khoảng thời gian hữu hạn, nhưng cuối cùng vẫn phải chuyển.</li>
  <li>Trong mạng đồng bộ 1 phần: tồn tại 1 sự kiện gọi là GST mà: Một msg gửi bởi 1 honest node ở thời gian t sẽ đến với người nhận trong khoảng thời gian:  Δ + Max(t, GST). 
<br />
Điều này tương đương với mạng sẽ không đồng bộ cho tới GST, sau đó sẽ đồng bộ</li>
</ul>

<h3 id="state-machine-replication-smr">State Machine Replication (SMR)</h3>
<p>Là phương pháp chung để triển khai dịch vụ chịu lỗi bằng việc sao chép máy chủ và điều phối tương tác của máy client với bản sao đó. Nó cung cấp framework để hiểu và thiết kết giao thức quản lý sao chép.</p>

<p>SMR gồm 2 phần:</p>
<ul>
  <li>Replicas: Nhận Tx, chạy giao thức SMR và xác định log. Các Log(Ledger) là chuỗi Tx thứ tự tuyến tính.</li>
  <li>Client: Giao tiếp với replicas để nhận log (ví dụ: wallet).
Các wallet không chạy giao thức SMR và cũng không giao tiếp với nhau. Nó hỏi các replicas về các log và chọn kết quả được nhiều replicas gửi về nhất.</li>
</ul>

<h3 id="bảo-mật-cho-smr">Bảo mật cho SMR</h3>
<p>Gọi A ≼ B khi A là tiền tố của B. Ví dụ: A = Tx1Tx2Tx3, B = Tx1Tx2Tx3Tx5Tx6 thì A là tiền tố của B.<br />
Gọi LOG(i, t) là log đưa ra bởi client i ở thời điểm t. Một giao thức SMR là an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  LOG(i, t) ≼ LOG(j, s) hoặc LOG(j, s) ≼ LOG(i, t) hoặc cả 2. =&gt; không thể xảy ra Double Spent</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ LOG(i, s).</li>
</ul>

<h2 id="giao-thức-blockchain">Giao thức Blockchain</h2>
<p>Các Txs được đóng thành các block để tăng thông lượng. Gọi CH(i, t) là chuỗi được accept bởi client i tại thời gian t. Giao thức blockchain đảm bảo an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  CH(i, t) ≼ CH(j, s) hoặc CH(j, s) ≼ CH(i, t) hoặc cả 2</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ CH(i, s).</li>
</ul>

<p>Mong muốn giao thức phải đảm bảo an toàn dưới môi trường bán đồng bộ. Theo DLS(1988), nếu f ≥ n/3 thì giao thức SMR không thể đảm bảo an toàn. Bây giờ với f &lt; n/3, ta sẽ chứng minh là giao thức này an toàn.</p>

<h2 id="chứng-minh">Chứng minh</h2>
<p>Thời gian chia thành các epoch, mỗi epoch là 2Δ giây. Có n replicas cố định, mỗi epoch e được chỉ định 1 leader Le bởi hàm Hash.</p>
<h3 id="baby-streamlet">Baby streamlet</h3>
<p><strong>Đề xuất khối: </strong> Ở đầu mỗi epoch, Le xác định chuỗi dài nhất nó từng thấy cho đến nay và sẽ đề xuất 1 khối liền sau chuỗi đó. <bn>
<strong>Finalization: </strong> 1 replica finalizes block (và tiền tố của nó) ở đầu chuỗi. Nếu có nhiều block như thế, chọn block có epoch nhỏ nhất.<br />
Tuy nhiên, có một nhược điểm là nếu Leader là adversary và network chưa đồng bộ, thì Adversary có thể gửi thông báo các Block cho 1 user bất kì, nhưng thông báo chưa tới các user còn lại cho tới sau GST. 
/// hình minh hoạ</bn></p>

<h3 id="teen-streamlet">Teen streamlet</h3>
<p>Votes: 1 vote trên block bởi replica là chữ kí của nó trên block. <br />
Notarization: 1 block được xem là Notarized dưới góc nhìn của replica nếu block đó có hơn 2n/3 chữ kí từ các replica khác.<br />
<strong>Đề xuất khối: </strong> Đầu mõi epoch e, Le xác định chuỗi Notarized dài nhất và đề xuất khối sau chuỗi Notarized này.<br />
<strong> Vote: </strong> ∆ giây ở epoch e,mỗi replica vote cho đề xuất hợp lệ đầu tiên dưới góc nhìn của Le (mở rộng chuỗi dài nhất theo góc nhìn của nó).<br />
<strong>Finalization: </strong>  1 replica finalize 1 block và tiền tố của nó sau khi thấy khối được notarized.</p>

<p>Ví dụ: /// hình ảnh <br />
Chứng minh: với f &lt; n/3, với mỗi epoch e, chỉ có tối đa 1 notarized block với epoch là e trong góc nhìn của bất kì replica trung thực nào. <br />
Giả sử 2 khối cùng epoch e là B và B’. Vì f &lt; n/3 nên tồn tại replica vote cho cả B, B’. Mà số vote của B và B’ lớn hơn 2/3 =&gt; số replica vote cho cả 2 là &gt; n/3. Đây là vô lý. Vậy khi network chưa đồng bộ, giao thức này đảm bảo an toàn.<br />
Với các block có epoch khác nhau, có thể cùng ở chung 1 độ cao. Gọi 2 block đó là B1 và B2. Ban đầu, ở B, adversarial đề xuất B1 cho 66 replica trung thực, nên B1 chưa được notarized (vì có 66 vote). Tiếp theo, B2 được đề xuất bởi 1 replica trung thực, và được notarized nhưng trong đó có 1 adversarial vote cho B1, nên B1 cũng được notarized. Từ đó dẫn đến vi phạm safety.</p>

<h3 id="streamlet">Streamlet</h3>
<p><strong>Finalization: </strong> Khi thấy 3 khối kề nhau trong chuỗi được notarized với epoch liên tiếp, thì client sẽ finalize block thứ 2 trong 3 block trên và tẩt cả tiền tố của nó.</p>

<p>Độ phức tạp giao tiếp là O(N^3) message cho mỗi block, vì mỗn honest replica chuyển tiếp các votes nó nhận từ các replica khác cho tất cả các replica.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.]]></summary></entry><entry><title type="html">Cấu tạo block và PoW</title><link href="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow" rel="alternate" type="text/html" title="Cấu tạo block và PoW" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow"><![CDATA[<p>Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).</p>

<h2 id="cấu-tạo-block-trong-bitcoin">Cấu tạo block trong bitcoin</h2>
<p>Các block chứa các dữ liệu về Tx được lưu vào trong sổ cái công khai. Block có các header, nơi chứa các siêu dữ liệu giúp quản lý block đó. Kích thước blockheader là 80 bytes, trong khi các giao dịch trung bình khoảng 250 bytes và mỗi khối trung bình chứa được 500 Tx.</p>

<p>Ở trong blockheader chứa các dữ liệu liên quan đến các block đó. Đầu tiên, là giá trị hash của block liền trước nó(32 bytes), giúp đảm bảo liên kết trong chuỗi. Tiếp theo là Version (4 bytes) là phiên bản của block hiện tại. Merkle Root cũng được lưu ở đây (32 bytes), là giá trị hash của của gốc cây Merkle của các Tx. 4 bytes Timestamp là chỉ thời gian block được tạo, được tính bằng số giây từ 01/01/1970. Tiếp theo là Hash Target/ Difficult Target (4 bytes) là giá trị hash mục tiêu của PoW cho block này. Cuối cùng là số nonce (4 bytes), là giá trị mà các miner tìm để giải bài toán PoW.</p>

<h2 id="proof-of-work">Proof of Work</h2>
<p>PoW là một phần dữ liệu khó tạo (là đáp án cho một bài toán) hoặc rất tốn kém, mất thời gian để tạo nhưng chỉ tốn 1 thời gian rất ngắn (đpt O(1)) để có thể kiểm tra xem đáp án đó có đúng không. Quy trình tạo dữ liệu này là ngẫu nhiên với xác suất thấp, cần thử sau rất nhiều lần trước khi tạo ra PoW hợp lệ.</p>

<p>PoW là cách để các nodes cùng đồng thuận về tình trạng của block, tránh việc <a href="https://academy.binance.com/vi/articles/double-spending-explained">chi tiêu khép</a>, từ đó cho phép cập nhập blockchain theo các quy tắc của hệ thống.</p>

<h3 id="ví-dụ-với-bitcoin">Ví dụ với Bitcoin:</h3>
<p>Trong quá trình tạo khối, các miner sẽ phải giải được bài toán tìm số nonce để đưa vào blockheader và khiến block hợp lệ. Block hợp lệ là block có hash nhỏ hơn target value hiện tại.
Hash của block là lấy (Tổng của: Merkle Root, Version, Timestamp, Target, PreviousHash, Nonce) hash 2 lần,nếu Hash này nhỏ hơn hoặc bằng Target, tức là block này hợp lệ. Block này sau đó sẽ được đưa vào chuỗi sau khi các nodes khác verify rằng nonce này là hợp lệ (với độ phức tạp O(1)). Ngược lại, các miner sẽ phải tìm số Nonce khác.</p>

<p>Độ khó (Target Hash) sẽ được thay đổi sau 2016 block (2 tuần) được sinh ra. Nếu thời gian sinh 2016 block này nhanh hơn, Target Hash sẽ được điều chỉnh xuống, ngược lại sẽ tăng lên. Sau khi cập nhập, các nodes cùng chia sẻ một Target.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>PoW là một cơ chế đồng thuận được sử dụng ở nhiều blockchain khác nhau, tuy nhiên nó cũng mang lại nhiều bất lợi. Những cơ chế đồng thuận khác sẽ được viết ở những bài sau.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).]]></summary></entry><entry><title type="html">Cơ chế Bitcoin</title><link href="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin" rel="alternate" type="text/html" title="Cơ chế Bitcoin" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/co-che-bitcoin</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin"><![CDATA[<p>Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.</p>

<h3 id="thời-gian-đóng-các-khối">Thời gian đóng các khối</h3>
<p>Cứ sau mỗi 10 phút, mỗi miner sẽ tạo 1 block tiềm năng từ các Tx trong mempool của nó. Các Tx được ưu tiên theo phí giao dịch. 1 miner được chọn (sau khi giải được bài toán PoW) sẽ phân tán block đó cho toàn mạng và mọi miner khác sẽ xem được block, sau đó block được đưa vào chuỗi. Phần thưởng là 6.25 BTC. Phần thưởng này được gửi cho miner thông qua coinbase Tx (là Tx đầu tiên trong block chứa địa chỉ ví của miner do ,miner thêm vào).</p>

<h2 id="cấu-trúc-của-một-transaction">Cấu trúc của một Transaction</h2>
<p>Transaction trong Bitcoin chia làm 2 phần chính là Input và Output.
Input gồm 3 phần chính:</p>
<ul>
  <li>Previous Tx ID: ID của Tx trước đó mà tạo ra Bitcoin ở Output để sử dụng trong giao dịch hiện tại.</li>
  <li>Previous Tx index: Vì một Tx có thể có nhiều Output nên index này được sử dụng để xác định output trong Tx trước đó. Danh sách các output được xem như 1 tập hợp bên trong Tx.</li>
  <li>ScriptSig: Script Signature. Nó mã hoá Public key và chữ kí của người sở hữu Bitcoin ở hiện tại.</li>
</ul>

<p>Output: là những bitcoin mới được khoá với Hash của Public Key của người nhận. Bitcoin sử dụng mô hình UTXO là Bitcoin chỉ có thể sử dụng 1 lần, sau mỗi giao dịch thì bitcoin cũ sẽ bị loại bỏ và một lượng bitcoin mới được tạo ra. Output gồm 2 phần chính:</p>
<ul>
  <li>Value: Số lượng bitcoin mà được gửi cho người nhận. (Min: 1 satoshi = 10^-8 BTC)</li>
  <li>ScriptPubKey: Là một dãy các chỉ dẫn (Như 1 hàm) mà nhận ScriptSig là Input và trả về True nếu người sở hữu hợp lệ mở khoá Bitcoin này. Ngược lại, nó trả về false.</li>
</ul>

<p>Một giao dịch có thể có nhiều Input và Output. Các input có thể từ nhiều user (gọi là MultiSig Tx), các output có thể đến nhiều user.</p>

<p>Ngoài ra, trong Tx còn có 2 phần khác là segwit và locktime.</p>

<h3 id="miner-xác-minh-một-tx-như-thế-nào">Miner xác minh một Tx như thế nào</h3>
<p>Một Tx thoả mãn khi:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPK trả về True. Tức là với điều kiện nào thì UTXO có thể được tiêu.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>TxID</td>
          <td>index: hiện ở trong tập các UTXO</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>tổng Input values &gt; tổng Output values: Không thể tiêu nhiều hơn số tiền đang có.
Sau khi 1 Tx được post lên, miners sẽ xoá UTXO tương ứng của nó trong tập.</li>
</ul>

<h2 id="các-loại-tx">Các loại Tx</h2>
<h3 id="pay-to-public-key-hash-p2pkh">Pay to public key hash (P2PKH)</h3>
<p>Trước tiên, mọi người cần hiểu về một số op codes hoạt động trong Bitcoin Script ở <a href="https://wiki.bitcoinsv.io/index.php/Opcodes_used_in_Bitcoin_Script">đây</a>. 
Giả sử Alice muốn gửi cho Bob 5BTC. Alice và Bob sẽ làm các bước sau:</p>
<ul>
  <li>Bob tạo sig : gọi Gen():  (pkB, skB)</li>
  <li>Bob tính địa chỉ bitcoin của mình bằng: addrB = H(pkB)</li>
  <li>Bob gửi addrB cho Alice</li>
  <li>
    <p>Alice tạo giao dịch Tx-fund với Output[0] là: UTXO[0]: 5, ScriptPkB với ScriptPkB là:</p>

    <p>DUP  HASH256  «addrB»  EQVERIFY  CHECKSIG</p>
  </li>
</ul>

<p>còn ở Input, Alice có ScriptSig để xác thực Bitcoin của Alice có chứa chữ ký của Alice lên Tx này, khiến cho không ai có quyền thay đổi ScriptPkB.</p>

<p>Sau đó, Bob muốn sử dụng UTXO[0] thì sẽ tạo 1 Tx-spend với ScriptSigB trong input, bao gồm «sig» và «pkB» với Sig = Sig(skB, Tx) (Tx này là Tx-spend nhưng không chứa các ScriptSig).</p>

<p>Miner có thể xác thực ScriptSigB|ScriptPkB = true và cho phép B sử dụng số tiền.
Một số lưu ý như:</p>
<ul>
  <li>Người nhận (Bob) không thể tiết lộ PkB cho đến khi UTXO được dùng (vì bảo mật).</li>
  <li>Vì tránh việc tấn công bằng cách thay đổi Sig, Sig được chuyển vào phần witness và TxID được tính bằng:               TxID = H(Tx không chứa witness).</li>
</ul>

<h3 id="pay-to-script-hash-p2sh">Pay to script hash (P2SH)</h3>
<p>Người nhận (Bob) thay vì tạo address là H(pkB) thì tạo 1 redeem script, sau đó gán địa chỉ để người gửi (Alice) chuyển qua thành H(redeem script).
Ví dụ:</p>
<ul>
  <li>ScriptPK ở UTXO: HASH160   «H(redeem script)»  EQUAL</li>
  <li>ScriptSig để tiêu: {sig1 , sig2, …, sign, redeem script}
Từ đây, người gửi (Alice) có thể thêm các điều kiện phức tạp để xác định khi nào người nhận (Bob) có thể tiêu.</li>
</ul>

<p>Reedem Script: là các điều kiện thoả mãn để có thể sử dụng UTXO như: số chữ kí tối thiểu, thời gian,…</p>

<p>Các miner xác minh bằng cách:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPk = true: Bob gửi đúng script.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ScriptSig = true: script là thoả mãn (tức là sẽ tồn tại điều kiện để Bob có thể dùng UTXO).</li>
</ul>

<h4 id="ví-dụ-multisig">Ví dụ: MultiSig</h4>
<p>Muốn dùng UTXO thì cần t/n chữ kí. Ví dụ với 2 / 3 chữ kí. Redeem Script và ScriptSig được viết như sau:</p>
<ul>
  <li>Redeem Script: 	2, PK1, PK2, PK3, 3, CHECKMULTISIG</li>
  <li>ScriptSig: 0, sig1, sig3, redeem script</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Ngoài những dạng Tx ở trên, sẽ có nhiều dạng Tx khác được sử dụng ở trong nhiều trường hợp cụ thể.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.]]></summary></entry><entry><title type="html">Tổng quan về Blockchain</title><link href="http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain" rel="alternate" type="text/html" title="Tổng quan về Blockchain" /><published>2023-07-14T00:00:00+07:00</published><updated>2023-07-14T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain"><![CDATA[<p>Blockchain là một xu thế đang khá nổi ở thời điểm hiện tại. Theo những gì mình tìm hiểu và học hỏi được, đây là những chia sẻ tổng quan của mình về blockchain</p>

<h2 id="blockchain-là-gì">Blockchain là gì</h2>
<p>Blockchain là một sổ cái số phi tập chung ghi lại các dữ liệu giao dịch một cách an toàn, được duy trì bởi các máy tính chuyên dụng trên mạng (hay gọi là các nodes). Nó đảm bảo tính toàn vẹn bất biến thông qua cơ chế mã hoá và đồng thuận. Khi một giao dịch đã được record, nó sẽ không thể bị thay đổi.</p>

<p>Nói một cách đơn giản, blockchain như một loại cơ sở dữ liệu đặc biệt, được duy trì phi tập trung bởi nhiều máy tính phân bổ khắp thế giới. Ngoài ra, dữ liệu trên từng block sắp xếp theo trình tự thời gian, và bảo mật bằng mật mã để tránh bị làm giả dữ liệu</p>

<h2 id="sự-phi-tập-trung-trong-blockchain">Sự phi tập trung trong blockchain</h2>
<p>Trong Blockchain, quyền quyết định và điều khiển của mạng lưới thì phân bổ cho các user thay vì tập trung tại 1 user hoặc 1 tổ chức. Các giao dịch (Tx) được verified và ghi vào mạng máy tính phân tán hoạt động cùng nhau để duy trì tính toàn vẹn.</p>

<p>Ở trong core, blockchain lưu giao dịch giữa 2 bên. Khi 1 user gửi 1 Tx, nó được truyền đi khắp mạng lưới. Các nodes xác minh giao dịch bằng xác minh chữ kí số (Digital Signature) và các thông tin khác. Khi giao dịch được xác minh, nó sẽ cùng với các Tx khác được thêm vào block. Các block sẽ liên kết với nhau bằng phương pháp mã hoá, tạo thành chuỗi. Quá trình xác minh và thêm vào chuỗi sẽ được thông qua cơ chế đồng thuận.</p>

<h2 id="cơ-chế-đồng-thuận-và-mã-hoá">Cơ chế đồng thuận và mã hoá</h2>
<p>Cơ chế đồng thuận là tập hợp các quy tắc chi phối các node có đồng thuận về trạng thái của chuỗi hiện tại và tính hợp lệ của giao dịch hay không. Điều này đảm bảo các nodes trong mạng sẽ đều có bản copy đầu đủ của sổ cái.</p>

<p>Mã hoá là chìa khoá duy trì bảo mật, minh bạch và chống giả mạo của blockchain. Có 2 cách mã hoá chính được sử dụng là Hash và cặp khoá. Với Hash, là hàm không thể đảo ngược, giúp chuyển 1 input ở 1 size bất kì sang 1 size cố định. Mỗi khối trong chuỗi chứa hash của khối liền trước nó, nên khi muốn thay đổi 1 khối thì cần phải thay đổi các khối tiếp theo. Điều này giúp giảm khả năng bị thay đổi của khối xuống còn rất nhỏ. Người dùng có 1 cặp khoá Secret - Public của mình. Khi tạo 1 Tx, người đó sử dụng Secret key để kí và tạo chữ kí số. Những người khác xác nhận tính xác thực của Tx này bằng cách áp dụng Public key của người gửi.</p>

<h2 id="crypto-currency">Crypto Currency</h2>
<p>Tiền điện tử (Tiền mã hoá) là 1 loại tiền kĩ thuật số phi tập trung, sử dụng mật mã để bảo mật. Nó có thể hoạt động độc lập với các trung gian như ngân hàng, cổng thanh toán,..
Việc phi tập trung tạo điều kiện thuận lợi cho các giao dịch ngang hàng (P2P) giữa các cá nhân thông qua các ví điện tử hoặc sàn giao dịch.
Các tiền điện tử luôn nằm trong blockchain. Trong trường hợp các sàn giao dịch, nó chứa Secret key cho phép người dùng truy cập vào các tiền đó.</p>

<h3 id="crypto-currency-hoạt-động-như-thế-nào-">Crypto Currency hoạt động như thế nào ?</h3>
<p>Crypto Currency sử dụng thuật toán toán học tiên tiến để bảo mật các giao dịch và bảo vệ dữ liệu khỏi bị truy cập hoặc thao tác trái phép. Các thuật toán phục vụ 2 chức năng chính là: Duy trì quyền riêng tư của người dùng và xác minh tính xác thực của Tx.</p>

<p>Crypto whitepaper là một document mô tả chi tiết kèm các thông số kĩ thuật về 1 dự án blockchain. Các thông tin nó bao gồm rất đa dạng, có thể kể đến như: project goals, works, tech, roadmap,…</p>

<h3 id="stable-coin">Stable coin</h3>
<p>Một loại tiền điện tử được thiết kế để duy trì một giá trị cố định. Nó có thể trace giá trị tiền tệ fiat (tiền tệ được các nước sử dụng chính thức) hoặc các loại tài sản khác.</p>

<h2 id="smartcontract">SmartContract</h2>
<p>Hợp đồng thông minh là một thoả thuận kĩ thuật số được lập trình và lưu trữ trong blockchain, tự vận hành không cần trung gian. Nó có tính bảo mật, minh bạch, cung cấp cho người dùng sự tự do trao đổi, an toàn, khi triển khai các giao dịch. Hợp đồng thông minh được xem là xương sống của các DApps.
Bất cứ ai truy cập vào blockchain có thể gọi SmartContract và tương tác với nó.</p>

<h2 id="dapp">DApp</h2>
<p>Decentralized Application (DApp) là ứng dụng phi tập trung được xây dựng trên các nền tảng blockchain. Các ứng dụng này sử dụng SmartContract, và hoạt động không cần sự can thiệp của bất kì bên trung gian nào. Với DApp, mọi thứ đều được mã hoá, bất biến, an toàn, bảo mật và không ai có quyền thay đổi, lừa đảo, gian lận.</p>

<h2 id="nodes">Nodes</h2>
<p>Là các moderators xây dựng cơ sở cho mạng phi tập trung. Nó lưu trữ bản copy của sổ cái, được đồng bộ hoá và lập trình để thực hiện các giao dịch theo sự đồng thuận của đa số. Các nodes có thể là các máy tính, router,…</p>

<h2 id="tạm-kết">Tạm Kết</h2>
<p>Đây chỉ là những khái niệm cơ bản về blockchain. Ở bài sau, mình sẽ đi sâu vào cách hoạt động cụ thể của Blockchain.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Blockchain là một xu thế đang khá nổi ở thời điểm hiện tại. Theo những gì mình tìm hiểu và học hỏi được, đây là những chia sẻ tổng quan của mình về blockchain]]></summary></entry><entry><title type="html">Kĩ thuật Blockchain</title><link href="http://localhost:4000/blog/2023/07/14/blockchain-technology" rel="alternate" type="text/html" title="Kĩ thuật Blockchain" /><published>2023-07-14T00:00:00+07:00</published><updated>2023-07-14T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/14/blockchain-technology</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/14/blockchain-technology"><![CDATA[<p>Blockchain cung cấp sự tin cây cho nhiều bên (mà không cần đến trung gian), đây là ứng dụng có thể xem là mạnh mẽ nhất của blockchain. Dưới đây, mình sẽ viết sâu hơn về các kĩ thuật được sử dụng trong blockchain.</p>

<h2 id="các-tầng-của-blockchain">Các tầng của Blockchain</h2>
<p>Blockchain có thể chia thành các tầng chính như sau:</p>
<h4 id="application-layer">Application layer:</h4>
<p>Bao gồm các DApps, Smartcontract, các phần mềm chạy trên đỉnh các network. Đây là tầng cho phép build các Apps và Service phục vụ người dùng.</p>

<h4 id="consensus-layer">Consensus layer:</h4>
<p>Là tầng mà các nodes đồng ý về tính hợp lệ của các giao dịch, dựa trên các cơ chế đồng thuận.</p>

<h4 id="network-layer">Network layer:</h4>
<p>Là tầng mà các nodes giao tiếp với nhau (P2P). Tầng này phục vụ việc kết nối, lan truyền các Tx và phân phối các dữ liệu trên mạng. Đây cũng là tầng mà các block được tạo ra và thêm vào chuỗi.</p>

<h4 id="data-layer">Data layer:</h4>
<p>Là tầng lưu trữ dữ liệu an toàn và bất biến. Các dữ liệu bao gồm sổ cái, cơ sở dữ liệu trạng thái (Hash, Merkle Tree, Tx, Chữ ký,..).</p>

<h4 id="hardware-layer">Hardware layer:</h4>
<p>Là tầng vật lý, các thiết bị như máy tính, servers, routers,…</p>

<p>Ở tầng Consensus, các nodes phải đảm bảo các tính chất sau:</p>
<ul>
  <li>Persistence: Khi các Tx và block được thêm vào chuỗi, không thể xoá bỏ</li>
  <li>Safety: Các thành viên tham gia (các nodes, người dùng) đều có chung 1 dữ liệu về sổ cái</li>
  <li>Liveness: các thành viên Honest (không phá hoại mạng blockchain) thêm được các giao dịch</li>
  <li>Open: Ai cũng có thể thêm các giao dịch.</li>
</ul>

<p>Cùng với đó, có những vấn đề xảy ra ở tầng Consensus này cần giải quyết đó chính là việc Network delays, Network Partition, Crash, Malice,.. dẫn đến danh sách các Tx có thể bị sai thứ tự, không đầy đủ,…</p>

<h2 id="mã-hoá">Mã hoá</h2>
<p>Hàm Hash H là một hàm mã hoá được sử dụng với ý nghĩa sau:
Với 2 tập hợp M và T có:  <img src="https://latex.codecogs.com/svg.image?%5Cleft%7CM%5Cright%7C%5Cgg%5Cleft%7CT%5Cright%7C" alt="a" /> thì hàm hash H: <img src="https://latex.codecogs.com/svg.image?%5Cleft%7CM%5Cright%7C%5Crightarrow%5Cleft%7CT%5Cright%7C" alt="a" />. Ví dụ khi input có giá trị lên đến cả megabyte, khi chuyển qua hàm hash H sẽ có dạng 32 bytes. <img src="https://latex.codecogs.com/svg.image?%5CLeftrightarrow%20T=%5Cleft%5C%7B0,1%5Cright%5C%7D%5E%7B256%7D" alt="a" /></p>

<p>Một hàm hash như trên gọi là chống trùng lặp nếu như rất khó để tìm ra 1 cặp (x, y) ∈ M sao cho x ≠ y mà H(x) = H(y). Hàm này còn được gọi là CRF (Collision Resistant Function).</p>

<h3 id="commit-dữ-liệu-lên-blockchain">Commit dữ liệu lên blockchain</h3>
<p>Nếu user A có file m:    <img src="https://latex.codecogs.com/svg.image?h=H(m)" alt="a" /> là cam kết ràng buộc cho m. Với một danh sách <img src="https://latex.codecogs.com/svg.image?S=(m1,m2,...mn),h=commit(S)(h=H(S))" alt="a" />. 
Khi user B đọc h, cho <img src="https://latex.codecogs.com/svg.image?(m_%7Bi%7D%5E%7B%7D,proof%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> có thể kiểm tra xem S[i] có bằng <img src="https://latex.codecogs.com/svg.image?m_%7Bi%7D%5E%7B%7D" alt="a" /> hay không.
Điều này tương đương với khi chạy hàm <img src="https://latex.codecogs.com/svg.image?verify(h,i,m_%7Bi%7D%5E%7B%7D,%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> sẽ ra 1 trong 2 kết quả: accept/reject.</p>

<p>Ngoài ra, để đảm bảm security, không thể tìm được bộ <img src="https://latex.codecogs.com/svg.image?%5Csmall%20(S,i,m,%5CPi)" alt="a" /> mà m ≠ S[i] và <img src="https://latex.codecogs.com/svg.image?verify(h,i,m_%7Bi%7D%5E%7B%7D,%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> = accept.</p>

<h3 id="merkle-tree">Merkle Tree</h3>
<p>Mục tiêu của Merkle tree là khi commit danh sách S ở trên, có thể chứng minh được mi = S[i]. 
Cây merkle được xây dựng như sau:</p>

<p>// Vẽ sau</p>

<p>Các phần tử, cha của chúng là H(nó, sibling kề nó). Ví dụ y1 là H(m1, m2). Bây giờ, với bài toán chứng minh ở trên, ví dụ cần chứng minh S[4] = m4, ta chỉ cần set Proof = (m3, y1, y6).
Lý do:</p>

<p><img src="https://latex.codecogs.com/svg.image?%5Csmall%20y2%5Cleftarrow%20H(m3,m4)%5C%5Cy5%5Cleftarrow%20H(y2,y1)%5C%5Ch'%5Cleftarrow%20H(y5,y6)." alt="a" /></p>

<p>Nếu h = h’ thì accept. Khi muốn post 1 block vào trong chain, cần viết commit(S) vào. Merkle tree được sử dụng để chứng minh một Tx có ở trong block.</p>

<h2 id="chữ-kí-số">Chữ kí số.</h2>
<p>Làm cách nào mà các nodes có thể xác thực được các Tx? Thực tế, để xác định cần 3 thuật toán:</p>
<ul>
  <li>Gen(): tạo ra cặp key  (pK, sK) cho user.</li>
  <li>Sign(sK, msg): người gửi kí secretKey với msg họ muốn gửi. Output: là 1 sig: σ</li>
  <li>Verify(pK, msg, σ). Output: accept / reject</li>
</ul>

<p>Khi tạo ra các Tx, user đưa Sk + msg để tạo ra chữ kí σ. Các verifier sẽ sử dụng pK, msg và σ để verify các Tx. Việc sử dụng chữ kí số này giúp đảm bảo uỷ quyền Tx, khả năng bầu cử và sự đồng thuận bỏ phiếu của user.</p>

<h2 id="tạm-kết">Tạm kết</h2>
<p>Ở phần này là những kĩ thuật phổ biến được sử dụng trong blockchain. Trong bài tiếp theo, mình sẽ đi sâu về cấu tạo của từng khối và cách hoạt động của PoW.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Blockchain cung cấp sự tin cây cho nhiều bên (mà không cần đến trung gian), đây là ứng dụng có thể xem là mạnh mẽ nhất của blockchain. Dưới đây, mình sẽ viết sâu hơn về các kĩ thuật được sử dụng trong blockchain.]]></summary></entry><entry><title type="html">Mở đầu</title><link href="http://localhost:4000/blog/2023/07/09/modau" rel="alternate" type="text/html" title="Mở đầu" /><published>2023-07-09T00:00:00+07:00</published><updated>2023-07-09T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/09/modau</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/09/modau"><![CDATA[<p>Bài đầu tiên sau khi create lại.</p>]]></content><author><name>vanhgggg</name></author><summary type="html"><![CDATA[Bài đầu tiên sau khi create lại.]]></summary></entry><entry><title type="html">Mình đã tạo một game bằng C++ và SDL2.0</title><link href="http://localhost:4000/blog/2023/03/06/tao-game-sdl" rel="alternate" type="text/html" title="Mình đã tạo một game bằng C++ và SDL2.0" /><published>2023-03-06T00:00:00+07:00</published><updated>2023-03-06T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/03/06/tao-game-sdl</id><content type="html" xml:base="http://localhost:4000/blog/2023/03/06/tao-game-sdl"><![CDATA[<p>Xin chào mọi người. Ở kì học thứ 2, mình được học môn Lập trình nâng cao, là môn thứ 2 để hướng dẫn học sinh về lập trình sau môn “Nhập môn lập trình” thuộc kì học 1. Tại môn này, mình đã được hướng dẫn làm một project game 2D bằng ngôn ngữ C++ và sử dụng SDL 2.0 để hỗ trợ. Đây là project đầu tiên của mình, và hôm nay mình sẽ viết về cách mà mình tạo ra nó.</p>

<h2 id="1-cài-đặt-môi-trường-và-sử-dụng-sdl20">1. Cài đặt môi trường và sử dụng SDL2.0</h2>
<p>Về môi trường cài đặt, mình đã được giảng viên dành 1 buổi trên lớp để hướng dẫn cụ thể các bước về tải thư viện SDL2.0, chỉnh sửa các câu lệnh và chạy thử. Mình code game này ở trên <b> CodeBlock </b>, và có dựa theo hướng dẫn sau để cài đặt môi trường: <b><a href="https://www.youtube.com/watch?v=Gj3iXwvKmUY">Youtube</a> </b>và <b><a href="https://lazyfoo.net/tutorials/SDL/01_hello_SDL/index.php">Lazyfoo</a></b>.
Về việc sử dụng SDL2.0, mình tham khảo trên website <b><a href="https://lazyfoo.net/tutorials/SDL/index.php">Lazyfoo</a></b>, ở đây có những hướng dẫn rất chi tiết theo từng bước, rất phù hợp cho việc tìm hiểu và học tập.</p>

<!--  -->

<p>Bài viết này, mình sẽ không đi sâu về mặt kĩ thuật cài đặt và xử lý (vì trong tài liệu trên website Lazyfoo ở trên đã nói rất kĩ từng phần) mà chủ yếu là hành trình mình tạo ra game này.</p>

<h2 id="2-ý-tưởng-về-game-này">2. Ý tưởng về game này</h2>
<p>Mình là một người rất đam mê tìm hiểu về các bí ẩn và đặc biệt là các truyền thuyết về truy tìm kho báu nên ý tưởng đầu tiên nảy ra trong đầu mình sẽ là làm game về đề tài này. Tuy nhiên, để cụ thể hoá ý tưởng thì là điều không hề dễ dàng. Lý do là vì trong những tài liệu hay bộ phim về truy tìm kho báu, nhân vật chính thường phải trải qua rất nhiều thử thách và cạm bẫy thì mới có thể tiến đến kho báu. Kết quả là sau một khoảng thời gian suy nghĩ, mình quyết định tạo ra các mini-game trong game này, với mỗi mini-game tượng trưng cho mỗi thử thách cần vượt qua với độ khó tăng dần, cùng với đó là việc xây dựng nội dung từng thử thách sao cho có tính logic và cốt truyện. Mình nghĩ rằng nếu như chỉ code một game đơn giản thì điểm cho project này sẽ không cao, nhưng nếu là tổng hợp của nhiều game như thế thì có thể sẽ khác. Tiếp theo, mình sẽ phát triển loại game là dạng game đồ hoạ Pixel, như một số game nổi tiếng: <b> Stardrew Valley </b>,<b> Harvest Town </b>,… Cuối cùng, khi ý tưởng gốc đã xong xuôi, mình sẽ đi vào phần chi tiết cho từng thử thách.</p>

<!--  -->

<h2 id="3-thử-thách-thứ-nhất">3. Thử thách thứ nhất.</h2>
<p>Khi bắt tay vào làm, mình vẫn chưa nghĩ ra được mini-game đầu tiên sẽ là gì cho phù hợp. Cho đến buổi thực hành thứ 2 ở môn này, giảng viên đã cho mình làm 1 bài tập nhỏ là sử dụng hàm Random trong C++ để tạo ra các số từ 1 đến 3, tương ứng với Kéo, Búa, Bao trong trò chơi <b> One - Two - Three </b> (Oẳn tù tì) huyền thoại. Từ đây, mình đã quyết định chưa Oẳn tù tì vào làm một mini-game đầu tiên, với độ khó là dễ, nhưng cũng dựa vào may mắn là chính. Và để thêm phần thú vị cho minigame này, mình đã xây dựng một cốt truyện nhỏ và đồ hoạ phù hợp để tăng tính hình thức và bắt mắt. Một bật mí nhỏ là khi chấm game này cho mình, thầy giảng viên phải chơi mini game này 3 lần mới có thể dành được chiến thắng.</p>

<!--  -->

<h2 id="4-thử-thách-thứ-hai">4. Thử thách thứ hai</h2>
<p>Thử thách này mình lên ý tưởng từ nhân vật tượng nhân sư Sphinx trong Ai Cập cổ đại. Nhân sư sẽ canh gác lăng mộ và chỉ cho phép người đi qua nếu họ trả lời đúng được câu hỏi của nó. Mình quyết định sẽ đưa nhân vật chính đi qua lăng mộ và phải trả lời câu hỏi của Nhân sư này. Tuy nhiên, để đơn giản (vì đây mới là thử thách số 2) nên nhân vật sẽ có 7 lần đoán số tuổi của Sphinx, với điều kiện là tuổi của Nhân sư là nhỏ hơn 100. Nếu đoán sai thì tất nhiên, nhân vật chính sẽ dừng chân tại đây. Đến đây, nhiều bạn sẽ hiểu được tại sao mình để là 7 lần đoán. Đó là dựa theo thuật toán tìm kiếm nhị phân mà mình đã được học từ môn Nhập môn lập trình.</p>

<!--  -->

<h2 id="5-thử-thách-thứ-ba">5. Thử thách thứ ba</h2>
<p>Sau khi làm xong 2 thử thách trên, mình nghĩ mình cần nâng cấp độ khó cho game lên một chút, và đòi hỏi thao tác của người chơi nhiều hơn. Trong nhiều bộ phim truy tìm kho báu kinh điển, nhân vật chính sẽ đi qua một đường hầm với nhiều bẫy ở xung quanh, đòi hỏi sự khéo léo và dẻo dai của nhân vật. Với ý tưởng này, mình cũng tạo ra một đường hầm để đi tới chìa khoá của kho báu, với rất nhiều bẫy như rắn độc, hố sâu dung nham, vòng lửa,… đòi hỏi người chơi phải nhanh nhẹn điều khiển để tránh mất máu đi đến đích để nhận chìa khoá.</p>

<p>Phần này đòi hỏi mình làm tỉ mỉ, từ việc điều hướng các vòng lửa, năng lượng cho tới việc xử lý va chạm và cân bằng lượng máu để có được trải nghiệm game tốt nhất.</p>

<!--  -->

<h2 id="6-thử-thách-cuối-cùng">6. Thử thách cuối cùng</h2>
<p>Việc mình kết thúc hành trình ở thử thách thứ 4 vì mình lười :v, nhưng thật ra mình nghĩ việc dừng ở minigame số 4 là đủ để mọi người có thể trải nghiệm toàn bộ game, và có thêm thời gian cho mình hoàn thiện phần code.</p>

<p>Ở phần này, nội dung thử thách là việc trốn chạy khỏi đám zombie bảo vệ kho báu trong một khoảng thời gian nhất định. Đây là thử thách mình tốn nhiều thời gian làm nhất (cũng là thử thách khó nhất) vì phải code rất nhiều phần như tự động bắn, tự động nâng cấp sức mạnh, di chuyển bản đồ khi nhân vật chuyển động… Đây là minigame mình lấy ý tưởng từ game <b><a href="https://store.steampowered.com/app/1794680/Vampire_Survivors/">Vampire Survivors</a></b>, nhưng mình làm đơn giản hơn rất nhiều. Ngoài ra, việc tự tạo các hình ảnh vũ khí, zombie,… cũng khiến mình cảm thấy khá là vất vả. Nhưng sau cùng, mình cũng tạo được 1 bản gọi là tạm được của tựa game này.</p>

<!--  -->

<h2 id="7-những-phần-phụ-khác">7. Những phần phụ khác</h2>
<p>Tất nhiên, để tạo được game Truy tìm kho báu này, không thể không kể đến những bản đồ, nhân vật, quái vật, vũ khí,… Về phần nhân vật, quái vật,… mình lấy từ trang <b><a href="https://opengameart.org">OpenGameArt</a></b>. Đây là trang web chia sẻ miễn phí các spritesheet nhân vật, vũ khí,… thuộc dạng pixel 2D. Ngoài ra, mình cũng sử dụng phần mềm <b> PhotoshopCS6</b> để chỉnh sửa, cắt ghép các phần sao cho phù hợp, tạo map, menu, bản đồ kho báu cho từng màn.</p>

<!--  -->
<p>Bên cạnh đó, mình cũng tạo các cốt truyện nhỏ trong mỗi thử thách, từ việc đi qua kim tự tháp để nhận chỉ dẫn cho đến vượt qua những cạm bẫy để lấy được chìa khoá kho báu, qua đó giúp đảm bảo tính hợp lý về cốt truyện tổng thể cho game.</p>

<h2 id="tổng-kết">Tổng kết</h2>
<p>Toàn bộ ở trên là những chia sẻ về quá trình làm game <b>Truy Tìm Kho Báu</b> của mình. Mọi người có thể tải mã nguồn của game tại <b><a href="https://github.com/VanhGer/Game_Treasure_Hunt">đây</a></b>. Hy vọng bài viết này sẽ giúp mọi người có một góc nhìn khác về việc lập trình một project game, một góc nhìn hứng thú và sáng tạo hơn.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Xin chào mọi người. Ở kì học thứ 2, mình được học môn Lập trình nâng cao, là môn thứ 2 để hướng dẫn học sinh về lập trình sau môn “Nhập môn lập trình” thuộc kì học 1. Tại môn này, mình đã được hướng dẫn làm một project game 2D bằng ngôn ngữ C++ và sử dụng SDL 2.0 để hỗ trợ. Đây là project đầu tiên của mình, và hôm nay mình sẽ viết về cách mà mình tạo ra nó.]]></summary></entry><entry><title type="html">Các mô hình phát triển phần mềm (P2)</title><link href="http://localhost:4000/blog/2023/03/03/mo-hinh-phat-trien-p2" rel="alternate" type="text/html" title="Các mô hình phát triển phần mềm (P2)" /><published>2023-03-03T00:00:00+07:00</published><updated>2023-03-03T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/03/03/mo-hinh-phat-trien-p2</id><content type="html" xml:base="http://localhost:4000/blog/2023/03/03/mo-hinh-phat-trien-p2"><![CDATA[<p>Ở phần 2 này, mình sẽ giới thiệu về 2 loại mô hình truyền thống còn lại là Bản mẫu (Prototype) và mô hình xoắn ốc (Spiral Model).</p>

<h2 id="3-bản-mẫu-prototype">3. Bản mẫu (Prototype)</h2>
<p>Thực tế, các yêu cầu đặc tả từ khách hàng rất hiếm khi rõ ràng, đầy đủ ngay từ đầu để thuận tiện cho việc sử dụng mô hình thác nước hay chữ V, nên mô hình bản mẫu được ra đời nhằm giải quyết vấn đề này. Bản mẫu là mô hình phát triển dựa trên việc thiết kế các bản thử của phần mềm theo yêu cầu của khách hàng, và khách hàng tham gia vào quá trình phát triển, từ đó giúp có cái nhìn tổng quát về hệ thống.
Mô hình bản mẫu: 
 <!--  -->
Trong sơ đồ trên, các pha có nhiều điểm tương đồng với mô hình thác nước. Tuy nhiên, ở pha tinh chế bản mẫu, các bản mẫu sau khi được khách hàng đánh giá, sẽ phải tinh chế theo các yêu cầu của khách hàng, rồi xây dựng lại bản mẫu khác đến khi đáp ứng những yêu cầu của khách hàng thì đưa sản phẩm.
Bản mẫu là mô hình có nhiều ưu điểm. Ưu điểm dễ nhận thấy nhất là việc nhanh có sản phẩm thử. Việc thực hiện bản mẫu cần có sản phẩm thử (bản mẫu) để khách hàng có thể đánh giá, từ đó giúp yêu cầu đặc tả kĩ càng hơn. Thứ hai là giải quyết các yêu cầu không rõ ràng. Việc đưa ra 1 bản mẫu, và thu thập yêu cầu của khách hàng dựa trên bản mẫu đó sẽ giúp ích cho khách hàng có thể hình dung ra được sản phẩm họ cần là gì, từ đó sẽ có đặc tả yêu cầu rõ ràng từ khách hàng, giúp cho việc phát triển phần mềm chính xác và đáp ứng được những gì khách hàng đưa ra.</p>

<p>Thực tế hiện nay, các bản mẫu được sử dụng để đề xuất cho khách hàng hoặc là một kĩ thuật thu thập yêu cầu cho các mô hình khác. Có nhiều lí do cho việc này. Thứ nhất, khi dồn chi phí và nhân lực cho việc phát triển bản mẫu, các công đoạn còn lại sẽ thiếu thời gian và chi phí. Nên kết quả là dù có đầy đủ yêu cầu rõ ràng nhưng sản phẩm vẫn gặp vấn đề về chất lượng, nhất là phần tài liệu và code.Thứ hai, việc chú trọng quá vào bản mẫu cho yêu cầu chức năng dẫn đến dễ bỏ qua các yêu cầu phi chức năng và đa số các dự án thường không đạt yêu cầu phi chức năng (ví dụ như không đạt hiệu suất thời gian, độ bảo mật, toàn vẹn dữ liệu, dễ tương tác, …).</p>

<h2 id="4-mô-hình-xoắn-ốc-spiral-model">4. Mô hình xoắn ốc (Spiral model):</h2>
<p>Mô hình xoắn ốc là một mô hình chú trọng vào tính rủi ro của những dự án. Xoắn ốc là sự kết hợp giữa các mô hình Thác nước và Bản mẫu và thêm phần Phân tích rủi ro ở trong. Ở đây, bản mẫu sử dụng để thu thập yêu cầu cho mô hình cũng như phát triển tăng dần, tuần tự. Mỗi giai đoạn trong mô hình xoắn ốc sẽ bắt đầu với yêu cầu, mục đích thiết kế và kết thúc với việc khách hàng kiểm tra tiến độ của sản phẩm.</p>

<p>Đây là mô hình có tỉ lệ thất bại cao khi áp dụng cho các dự án lớn. Bởi vì trước khi thực hiện một dự án, các nhà phân tích rủi ro sẽ nhận thông tin dự án, sau đó đánh giá rủi ro và quyết định xem có nên làm dự án này hay không. Nhưng việc khả thi của phân tích rủi ro là rất thấp vì các công ty phải cần người có chuyên môn cao và kinh nghiệm để có thể phân tích được những loại rủi ro này. Mà trên thị trường, việc các công ti vừa và nhỏ có thể có những con người như thế là rất hiếm gặp.</p>

<p>Ngoài ra, việc quản lý rủi ro, thực hiện các pha nhiều lần cần công sức rất lớn và tài nguyên, con người nên mô hình xoắn ốc được ít dự án sử dụng, chỉ có những công ty lớn với dự án quy mô rộng, nhiều nguồn lực, nhân lực ưu tú và việc phân tích rủi ro cho dự án rất quan trọng thì mới sử dụng mô hình này.</p>

<h2 id="5-tổng-hợp">5. Tổng hợp:</h2>
<p>Ở trên là các mô hình phát triển phần mềm truyền thống, được sử dụng qua rất nhiều dự án. Tuy nhiên, trong thực tế người phát triển sẽ dựa vào những mô hình này mà cải tiến, điều chỉnh sao cho phù hợp nhất đối với dự án của mình.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở phần 2 này, mình sẽ giới thiệu về 2 loại mô hình truyền thống còn lại là Bản mẫu (Prototype) và mô hình xoắn ốc (Spiral Model).]]></summary></entry><entry><title type="html">Các mô hình phát triển phần mềm (P1)</title><link href="http://localhost:4000/blog/2023/03/02/mo-hinh-phat-trien-p1" rel="alternate" type="text/html" title="Các mô hình phát triển phần mềm (P1)" /><published>2023-03-02T00:00:00+07:00</published><updated>2023-03-02T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/03/02/mo-hinh-phat-trien-p1</id><content type="html" xml:base="http://localhost:4000/blog/2023/03/02/mo-hinh-phat-trien-p1"><![CDATA[<p>Mô hình phát triển phần mềm là một quy trình tiêu chuẩn để phát triển phần mềm. Nó xác định các giai đoạn/ pha trong xây dựng phần mềm, từ lúc bắt đầu định hình yêu cầu cho đến khi phần mềm hoạt động được. Mô hình phát triển đóng vai trò rất quan trọng trong việc giúp các nhà phát triển thực hiện phần mềm một cách có hệ thống và hiệu quả, đảm bảo chất lượng và yêu cầu từ khách hàng.
Có rất nhiều loại mô hình phát triển như thác nước, bản mẫu, RAD, TDD,… Trong bài viết này, mình sẽ giới thiệu về 2 mô hình đầu tiên trên 4 loại mô hình phát triển truyền thống cơ bản là mô hình thác nước (Waterfall Model), mô hình chữ V (V-model), bản mẫu (Prototype) và mô hình xoắn ốc (Spiral Model).</p>

<h2 id="1-mô-hình-thác-nước">1. Mô hình thác nước.</h2>
<p>Mô hình thác nước là mô hình phát triển phần mềm theo quy trình tuần tự và liên tiếp. Sau khi kết thúc giai đoạn trước, thì mới chuyển sang giai đoạn sau, không thể có 2 giai đoạn được xử lý song song. Lý do bởi vì kết quả của giai đoạn này sẽ đóng vai trò là đầu vào, yêu cầu của giai đoạn tiếp theo.</p>

<p>Minh hoạ mô hình thác nước:</p>

<!--  -->

<p>Trong giai đoạn định nghĩa yêu cầu, các yêu cầu từ khách hàng sẽ được xác định và đặc tả chi tiết trong tài liệu, làm cơ sở để thực hiện giai đoạn thiết kế. Ở giai đoạn thiết kế, các nhà phát triển phải thảo luận, tìm ra yêu cầu của phần cứng, và đưa ra kiến trúc tổng thể của hệ thống phần mềm. Trong pha triển khai, nhà phát triển sẽ lập trình các chương trình nhỏ để tích hợp trong giai đoạn tiếp theo. Cuối cùng, sẽ là việc tích hợp các chương trình và kiểm thử trước khi đưa ra cho khách hàng sản phẩm.</p>

<p>Mô hình thác nước có những ưu điểm nổi trội về chất lượng và thoả mãn các yêu cầu phi chức năng. Thứ nhất là việc dễ học, dễ áp dụng. Việc làm các giai đoạn một cách tỉ mỉ, cẩn thận kèm theo việc viết tài liệu song song sẽ khiến cho phần mềm có tài liệu hướng dẫn kĩ càng, phục vụ cho việc sử dụng và đào tạo khách hàng. Về chất lượng đây là mô hình giúp sản phẩm có chất lượng cao vì các giai đoạn được làm cẩn thận, dành nhiều thời gian cho việc kiểm thử, tích hợp.</p>

<p>Bên cạnh các ưu điểm, mô hình này cũng bao gồm nhiều nhược điểm sau. Thứ nhất, đây là mô hình vận hành lâu, chi phí cao. Lí do là vì việc phát triển theo mô hình thác nước đảm bảo sản phẩm có chất lượng cao, do đó trong từng giai đoạn, phải làm một cách kĩ càng và cẩn thận bởi lẽ nếu sai phạm ở giai đoạn nào đó, việc quay ngược lên để sửa chữa là rất tốn thời gian. Ngoài ra, việc làm tài liệu, giảng giải các hoạt động ở giai đoạn trước để những người thực hiện giai đoạn sau có thể dễ dàng hiểu cũng tốn rất nhiều công sức của người làm phần mềm. Thứ hai là chỉ phù hợp với dự án vừa và nhỏ, có yêu cầu rõ ràng từ đầu các dự án nhỏ, vừa thì yêu cầu sẽ đơn giản hơn, do đó dễ thiết kế và thực hành hơn. Các dự án lớn thì có yêu cầu phức tạp, phạm vi dự án có thể thay đổi nên mô hình thác nước là rất khó xác định và đặc tả tổng thể các yêu cầu cùng 1 lúc. Thứ ba, mô hình thác nước sẽ khiến cho việc sản phẩm có chậm. Việc làm tuần tự và phải đảm bảo chất lượng cao dẫn đến tốc độ ra sản phẩm chậm. Do đó ảnh hưởng đến tiến độ của dự án. Ngoài ra, việc ra sản phẩm chậm thì sẽ có ít thời gian hướng dẫn khách hàng sử dụng sản phầm. Điều này sẽ dẫn đến việc trong quá trình sử dụng, khách hàng sẽ vô tình gây ra các lỗi cho phần mềm.</p>

<p>Trong thực tế, việc xây dựng các pha đầy đủ và không mắc phải lỗi nào là điều rất khó xảy ra. Nên khi trong quá trình phát triển, gặp phải vấn đề thì người phát triển phải quay lại các pha trước đó, tìm và sửa lỗi, rồi lại tiếp tục đi theo quá trình tuần tự và liên tục của model.</p>
<h2 id="2-v-model">2. V-model:</h2>
<p>Về vấn đề kĩ thuật, mô hình thác nước còn có các điểm cần khắc phục là việc kiểm thử vẫn đang quá chung chung, chưa được đề cập rõ ràng. Hơn nữa, việc sinh test muộn (bước cuối cùng mới sinh test để kiểm tra sản phẩm) sẽ dễ đến việc chât lượng bộ test thấp, không đủ tính khách quan. Từ đó khiến chất lượng của phần mềm sẽ không đảm bảo.Do vậy, V-model ra đời nhằm cải tiến những điểm yếu về kĩ thuật này.</p>

<!-- Minh hoạ V-model:  -->

<p>Mô hình chữ V cũng bao gồm các pha gần giống như thác nước. Tuy nhiên để tránh việc chung chung trong kiểm thử, mô hình này đã cụ thể các pha kiểm thử là kiểm thử tích hợp, kiểm thử hệ thống và kiểm thử cấp nhận. V-model đưa việc sinh các test song song với các giai đoạn. Ví dụ khi ở giai đoạn đặc tả yêu cầu, khi có yêu cầu, nhà phát triển sẽ sinh bộ test cho việc đặc tả đó, vv. Sau khi cài đặt xong, sẽ lấy những bộ test đó để kiểm tra hiểu quả của từng pha. Việc sinh test này sẽ khách quan hơn rất nhiều so với mô hình thác nước, và chất lượng bộ test cũng sẽ cao hơn. Lý do chính là việc sinh test do chủ quan người phát triển. Nếu như sinh test trước từng pha, test sẽ cụ thể hơn và giúp tăng khả năng phát hiện lỗi hơn rất nhiều. Ngược lại, việc sinh test sau khi có sản phẩm, bộ test sẽ rất chung chung, dễ pass.</p>

<p>Bên cạnh đó, việc kiểm thử được chia ra rất rõ ràng các pha như đã nói ở trên. Cụ thể thì unit test (kiểm thử đơn vị) sẽ chịu trách nhiệm kiểm tra từng thành phần phần mềm như mô hình thác nước. Kiểm thử tích hợp là nhóm các thành phần phần mềm do kiến trúc quy định, để kiểm tra sự tương tác của chúng với nhau. Đối tượng kiểm thử không phải là một hệ thống hoàn chỉnh. Ở pha kiểm thử hệ thống, hệ thống hoàn chỉnh sẽ được đội phát triển kiểm tra, đánh giá trước khi gửi cho khách hàng. Cuối cùng là kiểm thử chấp nhận, pha này sẽ do khách hàng dùng thử sản phẩm và đánh giá cuối cùng.</p>

<h2 id="tạm-kết">Tạm kết</h2>
<p>Ở trên là 2 trên 4 loại mô hình phát triển phần mềm truyền thống. Ở phần 2, mình sẽ giới thiệu thêm về bản mẫu và mô hình xoắn ốc.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Mô hình phát triển phần mềm là một quy trình tiêu chuẩn để phát triển phần mềm. Nó xác định các giai đoạn/ pha trong xây dựng phần mềm, từ lúc bắt đầu định hình yêu cầu cho đến khi phần mềm hoạt động được. Mô hình phát triển đóng vai trò rất quan trọng trong việc giúp các nhà phát triển thực hiện phần mềm một cách có hệ thống và hiệu quả, đảm bảo chất lượng và yêu cầu từ khách hàng. Có rất nhiều loại mô hình phát triển như thác nước, bản mẫu, RAD, TDD,… Trong bài viết này, mình sẽ giới thiệu về 2 mô hình đầu tiên trên 4 loại mô hình phát triển truyền thống cơ bản là mô hình thác nước (Waterfall Model), mô hình chữ V (V-model), bản mẫu (Prototype) và mô hình xoắn ốc (Spiral Model).]]></summary></entry></feed>