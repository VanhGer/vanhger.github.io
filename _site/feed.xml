<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-24T11:18:35+07:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Solidity và State Trie</title><link href="http://localhost:4000/blog/2023/07/23/solidity-va-state-trie" rel="alternate" type="text/html" title="Solidity và State Trie" /><published>2023-07-24T00:00:00+07:00</published><updated>2023-07-24T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/solidity-va-state-trie</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/solidity-va-state-trie"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie</p>

<h2 id="solidity">Solidity</h2>
<p>Solidity là ngôn ngữ lập trình cho Blockchain Ethereum, là ngôn ngữ hướng đối tượng, cấp cao để triển khai các smartcontracts. Smartcontract là chương trình chi phối các hành vi của Account trong Ethereum State. Account contract được tạo ra khi chạy một smartcontract. Mọi người có thể đọc account contract state ở trong storage array, nên không bao giờ được lưu trữ các bí mật trong contract.</p>

<p>Một số dạng biến của Solidity như: uint256, address(byte 32), bool,… Các loại tham chiếu là mảng, struct, string, map,… Khi một giao dịch đi từ A ⇾ B ⇾ C ⇾ D thì tại D, msg.sender là C, nhưng tx.origin là A.</p>

<p>ERC20 là API tiêu chuẩn cho fungible token, cung cấp các chức năng cơ bản để chuyển token hoặc cho phép token được sử dụng bởi bên thứ 3.</p>

<p>Các kiểu lưu trữ:</p>
<ul>
  <li>Stack variables: Rẻ để sử dụng, phù hợp với mọi loại dữ liệu (không qua 32 bytes)</li>
  <li>Calldata: Là 1 mảng byte chỉ đọc, tốn gas</li>
  <li>Memory: 1 byte mảng, rẻ, nhưng chi phí tăng theo cấp số nhân, lưu được dữ liệu &gt; 32 bytes</li>
  <li>Storage: Đắt, mappings và các biến state lưu trong này.</li>
  <li>Event logs: rẻ, không cần truy cập đến contract.</li>
</ul>

<p>Ở trên là một số hiểu biết của mình về solidity, về mặt coding, mọi người nên xem ở <a href="https://docs.soliditylang.org/en/latest/">đây</a>.</p>

<h2 id="state-trie-ethereum-state-trie">State trie (Ethereum state trie)</h2>
<p>Hình ảnh đây là cấu trúc được tạo bởi các loại State trong Ethereum: (ở góc phải dưới hình ảnh)</p>

<p><img src="https://i.stack.imgur.com/afWDt.jpg" width="900" height=" 600" /></p>

<p>Có 3 loại state chính là World state, Transaction, và Transaction Receipt.</p>

<h3 id="world-state-trie">World State Trie</h3>
<p>World State Trie Là mapping giữa địa chỉ và Account State. Nó được update bởi các Tx, và lưu trữ mọi thông tin về accounts và có thể lấy được qua các truy vấn.
Trong World State Trie có Account Storage Trie, nơi các dữ liệu liên kết với account được lưu trữ. Nó chỉ liên quan đến các contract account và mọi dữ liệu được ánh xạ giữa các số nguyên 32 byte.</p>

<p>Account State là các thông tin về một Ethereum account, như balance, nonce, storage Root, codehash,… và là lá của World State Trie.</p>

<h3 id="transaction-trie">Transaction Trie</h3>
<p>Transaction Trie lưu trữ các Tx trong Ethereum. Khi các Tx lưu trữ trong block, nó không thể bị thay đổi. Nó được xây dựng theo cấu trúc Modified Merkel Patricia Trie, và chỉ có node root mới được đưa vào trong block.</p>

<h3 id="transaction-receipt-triereceipt-trie">Transaction Receipt Trie(Receipt Trie)</h3>
<p>Transaction Receipt Trie lưu trữ đầu ra của các Txs. Đầu ra là kết quả của một Tx mà được chạy thành công, bao gồm H(Txs), block number, gas Used, địa chỉ của contract.</p>

<h3 id="ví-dụ-cấu-trúc-của-world-state-một-cách-đơn-giản">Ví dụ cấu trúc của World State (một cách đơn giản)</h3>
<p>Để đơn giản, ta giả sử các node lá của World State Trie chỉ bao gồm địa chỉ là số dư theo cặp Key - Value. 
Các loại thông tin:</p>
<ul>
  <li>Leaf Node: node lá của cây, chứa các trạng thái của 1 tài khoản có địa chỉ là Key</li>
  <li>Branch Node: gồm 16 ô, là các tiền tố của Key.</li>
  <li>Extension Node: node chỉ có 1 child</li>
  <li>Nibble: Là phần chung trong Key, 1 Nibble = 4 bits, lưu trong keyend hoặc shared nibble.</li>
  <li>Prefixes:
    <ul>
      <li>0: extension node có số chẵn Nibble</li>
      <li>1: extension node có số lẻ Niblle</li>
      <li>2: leaf node, có số chẵn Nibble</li>
      <li>3: leaf node, có số lẻ Nibble.</li>
    </ul>
  </li>
</ul>

<p>Minh Hoạ:
World State Trie với 4 cặp Key - Value như sau:</p>
<ul>
  <li>a711355: 45 ETH</li>
  <li>a77d337: 1 WEI</li>
  <li>a7f9365: 1.1 ETH</li>
  <li>a77d397: 0.12 ETH
<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiSYWqaPcJtBlnFR4VAaug.png" /></li>
</ul>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Ở trên là một số khái niệm sơ bộ về Solidity và cấu trúc của Ethereum, cụ thể về các State Trie.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie]]></summary></entry><entry><title type="html">Cơ chế Ethereum</title><link href="http://localhost:4000/blog/2023/07/23/ethereum-mechanics" rel="alternate" type="text/html" title="Cơ chế Ethereum" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/ethereum-mechanics</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/ethereum-mechanics"><![CDATA[<p>Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội</p>

<h3 id="so-sánh-chung">So sánh chung</h3>
<p>Bitcoin như một máy chuyển trạng thái. Bitcoin rule: S x I ⇾ S, với tập S là các trạng thái, I là tập tất cả các input. Còn với Ethereum, hàm chuyển trạng thái của nó sẽ phong phú hơn nhiều, và mỗi lần chuyển đổi thì sẽ thực hiện toàn bộ chương trình.</p>

<p>Ethereum hỗ trợ các DApp, với Program code được lưu trữ trên blockchain, khi chạy cũng sẽ thay đổi các trạng thái. Các block thì sẽ có khoảng 150 Tx, và các Block Proposer sẽ nhận Tx fee cho block và các phần thưởng khác khi tạo khối thành công.</p>

<p>Ngoài ra, ta đã biết rằng khi các block được proposer trong consensus layer (các beacon block, nên còn được gọi là beacon chain), các node gửi các Tx lên cho execution client hay còn gọi là compute layer để cập nhập các trạng thái (update world state).</p>
<h2 id="compute-layer">Compute layer</h2>
<p>World state: tập hợp các tài khoản được xác định bởi các địa chỉ 32 byte (Các thông tin như địa chỉ, số dư,..)</p>

<p>Có 2 loại tài khoản:</p>
<ul>
  <li>Owned account: Điều khiển bởi các cặp (Pk, Sk), hay là tài khoản của người dùng.</li>
  <li>Contracts: Điều khiển bởi code, được tạo lúc tài khoản được tạo, không thể thay đổi.</li>
</ul>

<p>Các dữ liệu cần thiết với mỗi account:
| Account Data  | Owned   | Contracts                   |
|—————|———|—————————–|
| address(tính) | H(Pk)   | H(CreatorAdd, CreatorNonce) |
| storage root  | Không   | StorageRoot                 |
| code          | không   | CodeHash                    |
| balance       | balance | balance                     |
| nonce         | nonce   | nonce                       |</p>

<p>Trong đó, nonce là số Tx mà acount đã thực hành, tính bằng (#Tx sent) + (#accounts created). Số nonce được dùng để chống replay và khi tạo mới thì luôn bằng 0 (với contract).  Các contract có thể bị ghi đè code, nhưng chỉ khi contract cũ đã SELFDESTRUCT.</p>

<p>Mỗi contract có 1 mảng lưu trữ liên quan gồm 2^256 phần tử, mỗi phần tử là 32 bytes. Và storage root là Merkle Patricia hash của mảng.</p>

<h3 id="chuyển-trạng-thái">Chuyển trạng thái</h3>
<h4 id="tx">Tx</h4>
<ul>
  <li>Được kí bởi người tạo.</li>
  <li>To: nếu = 0 là tạo account mới, code = (init, body). Còn lại là 32-bytes địa chỉ và data (những thứ mà contract gọi và các đối số).</li>
  <li>From: Địa chỉ khởi tạo và chữ kí vào Tx</li>
  <li>Value: số Ethereum được gửi.</li>
  <li>Tx fees: gasLimit, maxFee, maxPriorityFee (Sẽ nói rõ hơn ở phần sau).</li>
  <li>Nonce: Khớp với nonce hiện tại của người gửi, tránh việc replay Tx.</li>
  <li>Chain-id: đảm bảo giao dịch gửi đúng chuỗi (không thể dùng giao dịch testnet lên mainnet).</li>
</ul>

<h4 id="các-loại-tx">Các loại Tx</h4>
<ul>
  <li>owned ⇾ owned: chuyển ETH giữa các user</li>
  <li>owned ⇾ contract: gọi contract với ETH &amp; data</li>
</ul>

<h4 id="messages">Messages</h4>
<p>Là các Tx ảo được contract tạo ra, nó không có Signature (vì contract không có). Có 2 loại là:</p>
<ul>
  <li>contract ⇾ onwed: contract gửi tiền cho user</li>
  <li>contract ⇾ contract: contract gọi contract khác.</li>
</ul>

<h3 id="ethereum-block">Ethereum block</h3>
<p>Khác với Block của Bitcoin, Block Header của Ethereum có nhiều loại dữ liệu hơn, một số chính như:</p>
<ul>
  <li>Consensus data: các dữ liệu như Proposer Id, Previous hash, vote,…</li>
  <li>Address: Nơi mà gas fee được chuyển đến</li>
  <li>World state root: Merkle Patricia Tree Hash của tất cả các tài khoản</li>
  <li>Tx root: Merkle Tree Hash của Tx</li>
  <li>Tx receipt root: Merkle Hash của các log message</li>
  <li>Gas used: Sử dụng để điều chỉnh giá gas (ở phần sau).</li>
</ul>

<h3 id="evm-mechanics">EVM mechanics</h3>
<p>EVM là môi trường thực thi (execution). Các contract được viết bằng solidity, sau đó sẽ được compile thành EVM bytecode và được các validator sử dụng để chạy các contract. <br />
EVM hoạt động như một [Stack Machine] (https://en.wikipedia.org/wiki/Stack_machine) với lệnh JUMP (Các program sẽ bị huỷ nếu quá stack, proposer giữ lại gas).</p>

<h3 id="gas">Gas</h3>
<p>Gas được xem như là nguyên liệu của Ethereum, là khoản phí cần trả để thực hiện các giao dịch hay hoạt động tương tác với smartcontract. Mọi chỉ thị đều tốn gas, giúp ngăn việc gửi Tx có nhiều bước (tốn nhiều tiền hơn). Các Proposer có thể chọn các Tx từ mempool có phí gas cao để tối đa hoá thu nhập.</p>

<h4 id="gas-calculation">Gas calculation:</h4>
<p>Mỗi block có:</p>
<ul>
  <li>baseFee: gasPrice nhỏ nhất cho tất cả Tx trong block. BaseFee dựa vào tổng số gas ở block trước (Gas used ở header), nếu gasUsed là giới hạn (30M) thì baseFee tăng 12.5%, nếu block trước trống thì giảm 12.5%. Còn lại thì giữ nguyên.</li>
  <li>gasLimit: tổng gas cho phép với Tx</li>
  <li>maxFee: giá gas tối đa cho phép</li>
  <li>maxPriorityFee: ‘tips’ tối đa cho Proposer.</li>
</ul>

<p>GasPrice = min(maxFee, baseFee + maxPriorityFee) <br />
MaxTxFee = gasLimit x gasPice <br />
<strong> Cụ thể </strong></p>
<ul>
  <li>nếu gasPrice &lt; baseFee: dừng</li>
  <li>nếu MaxTxFee &gt; sender.balance: dừng</li>
  <li>trừ MaxTxFee khỏi sender.balance</li>
  <li>Đặt Gas = gasLimit</li>
  <li>Chạy Tx, trừ gas từ Gas với mỗi Tx. Nếu Gas &lt; 0 thì dừng, Proposer giữ gasLimit * gasPrice.</li>
  <li>Xong xuôi, trả lại Gas x gasPrice cho sender</li>
  <li>gasUsed = gasLimit - Gas. BURN gasUsed x baseFee và gửi gasUsed x (GasPrice - baseFee) cho block proposer.</li>
</ul>

<p>ETH bị BURN vì giúp giảm lạm phát, tăng tính khan hiếm, có lợi cho nhà đầu tư, chặn các proposer tạo ra các Tx giả, không khuyến khích các thoả thuận ngoài chuỗi.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Ở trên là toàn bộ hiểu biết của mình về cơ chế Ethereum.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội]]></summary></entry><entry><title type="html">Proof Of Stake</title><link href="http://localhost:4000/blog/2023/07/23/proof-of-stake" rel="alternate" type="text/html" title="Proof Of Stake" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/proof-of-stake</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/proof-of-stake"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.</p>

<h3 id="accountable-safety">Accountable Safety</h3>
<p>Một giao thức với resilence là n/3 khi giao thức đó an toàn nếu nó có ít hơn n/3 Adverserial node (Ví dụ streamlet). <br />
Một giao thức với Accountable Safety resilence n/3 là giao thức:</p>
<ul>
  <li>An toàn nếu ít hơn Adverserial node.</li>
  <li>Nếu vi phạm safety, thì những người giám sát (các node không phải người được chọn để đề xuất khối) có thể xác định rõ các node vi phạm.</li>
  <li>Không có cáo buộc sai với các node trung thực.</li>
</ul>

<h3 id="finality-và-dynamic-availability">Finality và Dynamic availability</h3>
<p>Gọi một giao thức là finality nếu nó duy trì safety trong thời gian không đồng bộ (trước GST). Ở các giao thức này, Tx được finalize nhanh hơn confirm trong bitcoin (60 phút). <br />
Gọi một giao thức là Dynamic availability nếu giao thức đó có thể tiếp tục confirm các giao dịch ngay cả khi nhiều node offline.</p>

<p>Không có giao thức SMR nào đảm bảo cung cấp cả 2. Do đó, một cách giải quyết là sử dụng Nested chains.</p>

<h3 id="nested-chains">Nested chains</h3>
<ul>
  <li>Available chain được xác định bởi giao thức Π_ava, thoả mãn Dynamic availability (VD: Nakamoto consensus).</li>
  <li>Finalized chain được xác định bởi giao thức checkpoint Π_fin thoả mãn security dưới mạng đồng bộ 1 phần.</li>
  <li>Chuỗi confirm bởi Π_ava là available chain.</li>
  <li>Π_fin kiểm tra các block trong availbale chain.</li>
  <li>Tiền tố của checkpoint cuối cùng tạo thành finalized chain. Tương đương với Finalized chain là prefix của available. Chuỗi này safe dưới mạng bất đồng bộ</li>
  <li>Các block của available chain luôn extend từ điểm checkpoint cuối cùng.</li>
</ul>

<p>Minh hoạ: hình ảnh</p>

<h2 id="proof-of-stake">Proof of Stake</h2>
<h3 id="tổng-quan">Tổng quan:</h3>
<ul>
  <li>Trong giao thức Pos, các nodes khoá (Stake) tiền của họ trong giao thức để đủ điều kiện tham gia consensus.</li>
  <li>Càng nhiều coin được stake bởi 1 node thì khả năng cao node đó được chọn làm validator. Vì thuật toán lựa chọn validator là giả ngẫu nhiên.</li>
  <li>Nếu node bị bắt quả tang thực hiện 1 hành động bất lợi (xác thực giao dịch sai) thì node đó sẽ bị burn số tiền đã stake và không thể tham gia vào quá trình đề xuất khối tiếp theo. (Slashing).</li>
</ul>

<p>Do đó, trong PoS, nodes sẽ có trách nhiệm trong cách hành động của mình. PoS giúp thay đổi cơ chế block được verify. Ngoài ra, để trở thành validator, các node phải có điều kiện (ví dụ: có ít nhất 32 ETH,..), sau khi đóng 1 khối, khối đó sẽ được các validator khác validate theo nhiều method khác nhau tuỳ vào blockchain.</p>

<h3 id="cụ-thể-với-ethereum-20">Cụ thể với Ethereum 2.0</h3>

<h4 id="chọn-validator-và-block-proposer">Chọn Validator và Block Proposer</h4>
<p>Để thành một validator, phải gửi ít nhất 32 ETH vào contract và chạy 3 phần mềm riêng biệt (sẽ giới thiệu ở sau) và tham gia hàng đợi. Thời gian của blocks chia thành các slot: 12s, epoch: 32 slot. Sau khi được active, validator đó sẽ tham ra vào quá trình phê duyệt. 1 validator ngẫu nhiên sẽ được chọn để xác thực giao dịch và đề xuất khối ở mỗi slot (Block proposer). Số còn lại sẽ làm giám sát để phê duyệt và kiểm tra xem validator đó có gian lận không.</p>

<p>Chọn Block Proposer quá trình giả ngẫu nhiên gồm nhiều yêu tố như staking age, số tiền stake,… Ở đây, mình sẽ giới thiệu 2 phương pháp lựa chọn là:</p>
<ul>
  <li><strong> Randomize block selection: </strong> lựa chọn bằng cách tìm kiếm nodes có sự kết hợp của hash value thấp nhất và stake cao nhất. Vì size của các stakes là công khai nên có thể dự đoán được.</li>
  <li><strong> Coin Age Selection: </strong> là phương thức chọn các nodes dựa vào khoảng thời gian stake. Coin Age được tính bằng: số ngày đặt cược x số lượng coin. Khi một node forge một block, coin age của nó được cài về 0.</li>
</ul>

<h4 id="quy-trình-xác-thực">Quy trình xác thực</h4>
<p>Khi một user tạo Tx và submit lên Ethereum, nó sẽ được kiểm tra tính hợp lệ (Ví dụ đảm bảo số tiền, key đúng,…) sau đó được đưa đến mempool và phát tán nó đến các node khác. <br />
Một node được chọn làm Block Proposer để đề xuất khối ở slot này, có trách nhiệm đóng và phát tán block vào chuỗi và cập nhập trạng thái. Nodes chạy 3 phần mềm:</p>
<ul>
  <li>Execution client: gộp các Txs từ mempool thành “execution payload” và chạy nó ở local để tạo ra sự thay đổi trạng thái. Thông tin này được chuyển đến consensus client</li>
  <li>Consensus client: đóng gói payload thành 1 phần của “beacon block” (gồm payload, slashing,…) cho phép mạng thống nhất trình tự về các khối.</li>
  <li>Validator client: Các node nhận được beacon block qua tầng gossip network. Sau đó chuyển đến Execution client của nó để chạy lại, nhằm chắc chắn trạng thái là đúng. Sau đóm Validator client sẽ chứng thực khối đó hợp lệ và là khối tiếp theo trong góc nhìn của chuỗi (available chain). Khối cũng được thêm vào cơ sở dữ liệu local của các node.</li>
</ul>

<h4 id="finality">Finality</h4>
<p>Như đã nói ở trên, các block của available chain luôn extend từ điểm checkpoint cuối cùng. Checkpoint là các block đầu tiên ở mỗi epoch. Các validators có thể vote cho cặp checkpoint (1 epoch), nếu ít nhất 2/3 vote cho nó, cặp checkpoint này sẽ được cập nhập, và các block nằm giữa sẽ được cập nhập thành finalized chain. Nếu chuỗi không thể finalized trong nhiều hơn 4 epoch liên tục, stake ETH từ các validator chống lại đa số sẽ bị biến mất, cho phép đa số chiếm hơn 2/3 và finalized chuỗi.</p>

<h2 id="lời-kết">Lời kết</h2>
<p>Ở trên là cách hoạt động cơ bản của POS. Mọi người có thể xem thêm các thông tin về POS trong Ethereum tại <a href="https://ethereum.org/vi/developers/docs/consensus-mechanisms/pos/">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.]]></summary></entry><entry><title type="html">Đồng thuận trên mạng</title><link href="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang" rel="alternate" type="text/html" title="Đồng thuận trên mạng" /><published>2023-07-22T00:00:00+07:00</published><updated>2023-07-22T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang"><![CDATA[<p>Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.</p>

<h2 id="bitcoin-mining">Bitcoin Mining</h2>
<p>Bitcoin chọn các nodes tham gia vào giao thức bằng các sử dụng POW, giải bài toán tìm số nonce (xem chi tiết <a href="http://127.0.0.1:4000/blog/2023/07/20/cau-tao-block-va-pow">tại</a>). 
Bitcoin sử dụng Nakamoto consensus: <br /> 
<strong> Quy tắc đề xuất: </strong> ở thời điểm nào, mỗi miner trung thực mở rộng chuỗi nặng nhất (với độ khó cao nhất).
<strong> Quy tắc confirmation: </strong> Miner confirm 1 block (với tiền tố của nó) mà ở độ sâu k trong chuỗi nó nhìn được.</p>
<ul>
  <li>Ví dụ trong thực tế: k = 6.</li>
  <li>Miner và client chấp nhận các Tx ở block cuối cùng được confirm và tiền tố của nó như là log.</li>
  <li>Leader được chọn bởi POW.</li>
</ul>

<p>So sánh giữa Bitcoin và Streamlet /// ảnh <br /></p>
<ul>
  <li>Streamlet thì không dynamic available: Nó sẽ không đảm bảo liveness nếu n/3 hoặc hơn các nodes offline.</li>
  <li>Bitcoin thì dynamic available: tiếp tục confirm Tx khi miningpower offline. <br /></li>
</ul>

<h2 id="consensus-ở-internet">Consensus ở Internet</h2>
<p>Các nodes tham gia mở, tức là các adversary có thể tạo nhiều node và người tham gia trung thực có thể online hoặc offline và đi tuỳ ý. Do đó, mục tiêu đặt ra là phải hạn chế sự tham gia của Adversary, đồng thời duy trì dynamic available của giao thức.</p>

<h2 id="security">Security</h2>
<p>Bitcoin đảm bảo an toàn dưới mạng đồng bộ, với tỉ lệ mining power do Adversary kiểm soát 𝜷 &lt; 1/2</p>

<h3 id="nakamotos-private-attack-𝜷--12">Nakamoto’s Private Attack: 𝜷 ≥ 1/2</h3>
<p>Khi adversay đào block mới, nhưng không công bố. Các miner trung thực tiếp tục đào mà không biết về các block ẩn này. Khi adversary công bố chuỗi đó (đã tạo đủ block), chuỗi đó trở thành chuỗi dài hơn chuỗi mà miners trung thực đào được (vì 𝜷 ≥ 1/2), các block đào bởi các miner trung thực sẽ bị bỏ.</p>
<h3 id="forking">Forking</h3>
<p>Vì Network delay, các honest blocks ở cùng 1 độ cao. Do đó, tỉ lệ phát triển các khối honest sẽ chậm hơn so với 1 - 𝜷. Do đó, Adversary sẽ thành công nếu 𝜷 ≥ (1 - 𝜷) / 2 (Trường hợp chỉ có 2 chuỗi fork).</p>
<h3 id="security-1">Security</h3>
<p>Nếu 𝜷 &lt; 1/2, tồn tại tỉ lệ Mining đủ nhỏ 𝜆(Δ,𝛽) = 𝜆A + 𝜆H mà Bitcoin thoả mãn security với tỉ lệ lỗi chấp nhận là 𝑒^(−Ω(𝑘)) dưới mạng đồng bộ. Đây là xác xuất lỗi với comfirmation. Đây chính là lý do sau 10 phút mới tạo ra khối mới chứ không phải là 1 giây.</p>

<h4 id="chứng-minh">Chứng minh</h4>
<p>Nhận thấy, với các khối trung thực được tạo, vẫn có thể tạo ra fork vì khối sau được tạo ra quá gần khối trước (&lt; Δ). Lúc này, khối tạo sau được gọi là Tailgater. Ngược lại, nếu khối được tạo ở thời điểm t, và không tồn tại khối nào được tạo trong khoảng thời gian từ t - Δ đến t, thì khối đó được gọi là Non-Tailgater. Các khối Non-Tailgater thì có độ cao riêng biệt nhau.</p>

<p>Giờ, ta cần tìm tỉ lệ các khối trung thực là Tailgater hoặc Non-Tailgater. Xem thời gian tạo các khối là biến ngẫu nhiên Poisson, thì khoảng thời gian T giữa 2 khối tuân theo phân bố mũ. <br /> 
Gọi mining rate là λ (1/ minutes). Với Bitcoin λ = 1/10.<br />
Theo phân bố mũ, xác suất để T lớn hơn s bất kì là: P[T &gt; s] = 𝑒^(-λs). Suy ra, nếu s = Δ thì tỉ lệ honest block tạo ra là Non-Tailgater là g = P[T &gt; Δ] =  𝑒^(-λΔ), Tailgater là 1 - g.</p>

<p>Ta thấy, các Non-tailgater block tăng với tỉ lệ: gλ, các block này có height khác nhau, vì thế chuỗi dài nhất cũng tăng ít nhất với tỉ lệ này. =&gt; liveness.</p>

<p>Với Safety, ta cần thêm các khái niệm sau:</p>
<ul>
  <li>Block B được đào ở thời gian t, nếu không có honest block nào khác được đào từ t−Δ đến t+Δ thì B gọi là loner. Do đó, loner là block duy nhất ở độ cao đó. <br />
Để vi phạm safety, cần phải có hai chuỗi khác nhau hơn k khối, cả hai đều được thông qua bởi các node trung thực. Điều này tương đương với các Adversary phải khai thác các khối nhanh hơn các khối loner được tạo ra. Gọi tỉ lệ mine của Adversary là 𝜷. Tỉ lệ mine loner là g * g * λ. <br /> Do đó, Nakamoto đảm bảo security nếu g * g * λ &gt; 𝜷.</li>
</ul>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Nếu mọi người muốn xem chi tiết về cách chứng minh, hãy truy cập vào <a href="https://eprint.iacr.org/2019/943.pdf">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.]]></summary></entry><entry><title type="html">Bitcoin Scripts và Ví</title><link href="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet" rel="alternate" type="text/html" title="Bitcoin Scripts và Ví" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/bitcoin-scripts-and-wallet</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet"><![CDATA[<p>Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.</p>

<h3 id="một-số-lưu-ý">Một số lưu ý</h3>
<ul>
  <li>Các Tx sau khi thêm vào khối sẽ không thể bị xoá, do đó khi Tx nhầm thì sẽ bị khoá hoặc mất tiền.</li>
  <li>Các TxID là độc nhất, vì Input của chúng là độc nhất. Có trường hợp ngoại lệ là các Coinbase vì chúng không có input. Do đó có thể có trùng TxID. Vì vậy, người ta thường thêm Block Height và mỗi ScriptPk của coinbase.</li>
</ul>

<h2 id="ví-dụ-về-các-loại-bitcoin-scripts">Ví dụ về các loại Bitcoin Scripts</h2>
<h3 id="bảo-vệ-tài-sản-với-co-signatory">Bảo vệ tài sản với co-signatory</h3>
<p>addr = 2 - of - 2 (PkA, PkS) với PkS là của custody server.</p>

<h3 id="escrow-service">Escrow Service</h3>
<p>Giả định: A muốn mua balo từ B với giá 0.1 BTC, nhưng A chỉ có thể trả tiền khi balo đến, và không thể không trả. Do vậy, addr có dạng: 2-of-3 (PkA, PkB, PkJ).</p>

<p>Cách vận hành:</p>
<ul>
  <li>A thông báo cho B rằng muốn mua balo với giá 0.1 BTC</li>
  <li>A post 1 Tx 0.11 BTC đến addr trên (0.01BTC để đảm bảo A sẽ trả tiền cho B).</li>
  <li>B khi thấy Tx, gửi balo cho A</li>
  <li>Khi A nhận, gửi SigA trong Tx trên cho B</li>
  <li>B sẽ sử dụng SigA và SigB để lấy số tiền mà A gửi lên Addr.</li>
</ul>

<p>Nếu vi phạm xảy ra:</p>
<ul>
  <li>B không đưa balo, A sẽ lấy lại tiền với sự trợ giúp của Judge (PkJ).</li>
  <li>A không đưa SigA, B sẽ lấy tiền với sự giúp đỡ của Judge, A mất thêm 0.01BTC.</li>
</ul>

<h2 id="ví">Ví</h2>
<p>Ví giúp user tạo ra các cặp Pk- Sk, tạo ra và xác minh các Tx, đưa ra số dư mà user có.</p>

<h3 id="giúp-đơn-giản-hoá-xác-minh-thanh-toán">Giúp đơn giản hoá xác minh thanh toán</h3>
<p>Để xác minh một thanh toán đã thực hiện, ví thường tải các block headers. Sau đó, ví gửi lên server danh sách các địa chỉ mà ví đang nắm giữ. Sau đó, server sẽ gửi về ví các Tx liên quan đến địa chỉ và Merkle Proof của Tx đó. Từ đó giúp ví hiển thị đúng số dư và xác minh Tx.</p>

<h3 id="vấn-dề">Vấn dề</h3>
<ul>
  <li>Để giải quyết được yếu tố bảo mật, blockheader sẽ được tải từ 10 servers khác nhau hoặc từ 1 nodes tin cậy.</li>
  <li>Remote server có thể kiểm tra xem addr gửi lên có thuộc về ví hay không.</li>
</ul>

<h3 id="các-loại-ví">Các loại ví</h3>
<h4 id="hot-wallet">Hot wallet</h4>
<ul>
  <li>Dạng ví điện tử có kết nối Internet, có nhiều chức năng như lưu trữ, gửi nhận Tx, tokens,…</li>
  <li>Có thể truy cập từ các thiết bị Internet như máy tính, điện thoại,..</li>
  <li>Có thể bị hack hoặc xâm nhập bởi các hacker.</li>
</ul>

<h3 id="cold-wallet">Cold wallet</h3>
<ul>
  <li>Không cho phép kết nối Internet.</li>
  <li>Có thiết bị riêng cho cold wallet, thiết bị này phải được khởi động bất cứ khi nào sử dụng và người dùng phải sao chép vật lý dữ liệu từ online device sang offline và ngược lại.</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Có nhiều loại Bitcoin Script khác như CrossChain,… được sử dụng rất phổ biến ở hiện tại.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.]]></summary></entry><entry><title type="html">Cơ bản về đồng thuận</title><link href="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus" rel="alternate" type="text/html" title="Cơ bản về đồng thuận" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus"><![CDATA[<p>Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. 
Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.</p>

<h2 id="tác-hại-của-adversary">Tác hại của Adversary</h2>
<p>Có thể gây:</p>
<ul>
  <li>Lỗi crash: Nếu các nodes này không gửi và nhận các msg (message)</li>
  <li>Lỗi bỏ sót: Nếu các nodes này chọn hoặc bỏ qua các msg</li>
  <li>Lỗi Byzantine: Các node sai có thể đi lệch khỏi giao thức.</li>
</ul>

<p>Có 2 loại adversary</p>
<ul>
  <li>Static: phá huỷ node mà nó chọn trước khi bắt đầu giao thức.</li>
  <li>Adaptive: có thể phá huỷ các node khi giao thức xảy ra.
<br />
Giới hạn sức mạnh của adversary là số node:  f. Ví dụ: f &lt; n/2, f &lt; n/3.</li>
</ul>

<h2 id="các-nodes-giao-tiếp-với-nhau">Các nodes giao tiếp với nhau</h2>
<p>Các nodes gửi các tin nhắn (message) cho nhau trong giao thức. Giả sử một node adversary đang điều khiển việc gửi tin nhắn:</p>
<ul>
  <li>Trong một mạng đồng bộ: Adversary phải chuyển tin nhắn bất kì trong thời gian Δ giây (Δ đã biết).</li>
  <li>Trong mạng không đồng bộ: Adversary có thể hoãn msg trong 1 khoảng thời gian hữu hạn, nhưng cuối cùng vẫn phải chuyển.</li>
  <li>Trong mạng đồng bộ 1 phần: tồn tại 1 sự kiện gọi là GST mà: Một msg gửi bởi 1 honest node ở thời gian t sẽ đến với người nhận trong khoảng thời gian:  Δ + Max(t, GST). 
<br />
Điều này tương đương với mạng sẽ không đồng bộ cho tới GST, sau đó sẽ đồng bộ</li>
</ul>

<h3 id="state-machine-replication-smr">State Machine Replication (SMR)</h3>
<p>Là phương pháp chung để triển khai dịch vụ chịu lỗi bằng việc sao chép máy chủ và điều phối tương tác của máy client với bản sao đó. Nó cung cấp framework để hiểu và thiết kết giao thức quản lý sao chép.</p>

<p>SMR gồm 2 phần:</p>
<ul>
  <li>Replicas: Nhận Tx, chạy giao thức SMR và xác định log. Các Log(Ledger) là chuỗi Tx thứ tự tuyến tính.</li>
  <li>Client: Giao tiếp với replicas để nhận log (ví dụ: wallet).
Các wallet không chạy giao thức SMR và cũng không giao tiếp với nhau. Nó hỏi các replicas về các log và chọn kết quả được nhiều replicas gửi về nhất.</li>
</ul>

<h3 id="bảo-mật-cho-smr">Bảo mật cho SMR</h3>
<p>Gọi A ≼ B khi A là tiền tố của B. Ví dụ: A = Tx1Tx2Tx3, B = Tx1Tx2Tx3Tx5Tx6 thì A là tiền tố của B.<br />
Gọi LOG(i, t) là log đưa ra bởi client i ở thời điểm t. Một giao thức SMR là an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  LOG(i, t) ≼ LOG(j, s) hoặc LOG(j, s) ≼ LOG(i, t) hoặc cả 2. =&gt; không thể xảy ra Double Spent</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ LOG(i, s).</li>
</ul>

<h2 id="giao-thức-blockchain">Giao thức Blockchain</h2>
<p>Các Txs được đóng thành các block để tăng thông lượng. Gọi CH(i, t) là chuỗi được accept bởi client i tại thời gian t. Giao thức blockchain đảm bảo an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  CH(i, t) ≼ CH(j, s) hoặc CH(j, s) ≼ CH(i, t) hoặc cả 2</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ CH(i, s).</li>
</ul>

<p>Mong muốn giao thức phải đảm bảo an toàn dưới môi trường bán đồng bộ. Theo DLS(1988), nếu f ≥ n/3 thì giao thức SMR không thể đảm bảo an toàn. Bây giờ với f &lt; n/3, ta sẽ chứng minh là giao thức này an toàn.</p>

<h2 id="chứng-minh">Chứng minh</h2>
<p>Thời gian chia thành các epoch, mỗi epoch là 2Δ giây. Có n replicas cố định, mỗi epoch e được chỉ định 1 leader Le bởi hàm Hash.</p>
<h3 id="baby-streamlet">Baby streamlet</h3>
<p><strong>Đề xuất khối: </strong> Ở đầu mỗi epoch, Le xác định chuỗi dài nhất nó từng thấy cho đến nay và sẽ đề xuất 1 khối liền sau chuỗi đó. <bn>
<strong>Finalization: </strong> 1 replica finalizes block (và tiền tố của nó) ở đầu chuỗi. Nếu có nhiều block như thế, chọn block có epoch nhỏ nhất.<br />
Tuy nhiên, có một nhược điểm là nếu Leader là adversary và network chưa đồng bộ, thì Adversary có thể gửi thông báo các Block cho 1 user bất kì, nhưng thông báo chưa tới các user còn lại cho tới sau GST. 
/// hình minh hoạ</bn></p>

<h3 id="teen-streamlet">Teen streamlet</h3>
<p>Votes: 1 vote trên block bởi replica là chữ kí của nó trên block. <br />
Notarization: 1 block được xem là Notarized dưới góc nhìn của replica nếu block đó có hơn 2n/3 chữ kí từ các replica khác.<br />
<strong>Đề xuất khối: </strong> Đầu mõi epoch e, Le xác định chuỗi Notarized dài nhất và đề xuất khối sau chuỗi Notarized này.<br />
<strong> Vote: </strong> ∆ giây ở epoch e,mỗi replica vote cho đề xuất hợp lệ đầu tiên dưới góc nhìn của Le (mở rộng chuỗi dài nhất theo góc nhìn của nó).<br />
<strong>Finalization: </strong>  1 replica finalize 1 block và tiền tố của nó sau khi thấy khối được notarized.</p>

<p>Ví dụ: /// hình ảnh <br />
Chứng minh: với f &lt; n/3, với mỗi epoch e, chỉ có tối đa 1 notarized block với epoch là e trong góc nhìn của bất kì replica trung thực nào. <br />
Giả sử 2 khối cùng epoch e là B và B’. Vì f &lt; n/3 nên tồn tại replica vote cho cả B, B’. Mà số vote của B và B’ lớn hơn 2/3 =&gt; số replica vote cho cả 2 là &gt; n/3. Đây là vô lý. Vậy khi network chưa đồng bộ, giao thức này đảm bảo an toàn.<br />
Với các block có epoch khác nhau, có thể cùng ở chung 1 độ cao. Gọi 2 block đó là B1 và B2. Ban đầu, ở B, adversarial đề xuất B1 cho 66 replica trung thực, nên B1 chưa được notarized (vì có 66 vote). Tiếp theo, B2 được đề xuất bởi 1 replica trung thực, và được notarized nhưng trong đó có 1 adversarial vote cho B1, nên B1 cũng được notarized. Từ đó dẫn đến vi phạm safety.</p>

<h3 id="streamlet">Streamlet</h3>
<p><strong>Finalization: </strong> Khi thấy 3 khối kề nhau trong chuỗi được notarized với epoch liên tiếp, thì client sẽ finalize block thứ 2 trong 3 block trên và tẩt cả tiền tố của nó.</p>

<p>Độ phức tạp giao tiếp là O(N^3) message cho mỗi block, vì mỗn honest replica chuyển tiếp các votes nó nhận từ các replica khác cho tất cả các replica.
Chứng minh tính an toàn:<br />
<strong> Safety: </strong> Giả sử có 2 block đang trong tình trạng confict ở epoch e và e’. Nếu: <br /></p>
<ul>
  <li>e = e’: không thể (đã chứng minh ở Teen Streamlet).<br /></li>
  <li>e &lt; e’: suy ra e+1 &lt; e’. Vì B3 được notarized nên có ít nhất S &gt; n/3 replica trung thực vote cho B3 tại e+1. Vậy S sẽ thấy B2 được notarized ở đầu epoch e+1, do đó, S sẽ không vote cho B’ vì B’ không mở rộng từ chuõi dài nhất. Mà S &gt; n/3 nên B’ không được notarized. <br /></li>
  <li>e &gt; e’: suy ra e-1 &gt; e’. Nếu B’ được notarized, có S &gt; n/3 replica trung thực vote cho nó tại epoch e’. Vậy S sẽ thấy B” được notarized ở đầu epoch e”, do đó S sẽ không vote cho B1. Tương tự, B1 không được notarized. Điều này trái với giả thiết.<br />
Hình Minh Hoạ: <br />
Vậy, Streamlet đảm bảo safety<br /></li>
</ul>

<p><strong> Liveness: </strong> Giả sử có 4 slot liên tiếp: e, e + 1, e + 2, e + 3 với leader trung thực sau GST. Ở cuối các slot này, client sẽ finalize block được đề xuất bởi các replica trung thực. Trong đó:</p>
<ul>
  <li>1 slot để undo các hành động của adversary. <br /></li>
  <li>3 slot để finalize block. <br />
Ngoài ra, đảm bảo không có 2 block liên tiếp nhau mà chưa được notarized.</li>
</ul>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.]]></summary></entry><entry><title type="html">Cơ chế Bitcoin</title><link href="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin" rel="alternate" type="text/html" title="Cơ chế Bitcoin" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/co-che-bitcoin</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin"><![CDATA[<p>Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.</p>

<h3 id="thời-gian-đóng-các-khối">Thời gian đóng các khối</h3>
<p>Cứ sau mỗi 10 phút, mỗi miner sẽ tạo 1 block tiềm năng từ các Tx trong mempool của nó. Các Tx được ưu tiên theo phí giao dịch. 1 miner được chọn (sau khi giải được bài toán PoW) sẽ phân tán block đó cho toàn mạng và mọi miner khác sẽ xem được block, sau đó block được đưa vào chuỗi. Phần thưởng là 6.25 BTC. Phần thưởng này được gửi cho miner thông qua coinbase Tx (là Tx đầu tiên trong block chứa địa chỉ ví của miner do ,miner thêm vào).</p>

<h2 id="cấu-trúc-của-một-transaction">Cấu trúc của một Transaction</h2>
<p>Transaction trong Bitcoin chia làm 2 phần chính là Input và Output.
Input gồm 3 phần chính:</p>
<ul>
  <li>Previous Tx ID: ID của Tx trước đó mà tạo ra Bitcoin ở Output để sử dụng trong giao dịch hiện tại.</li>
  <li>Previous Tx index: Vì một Tx có thể có nhiều Output nên index này được sử dụng để xác định output trong Tx trước đó. Danh sách các output được xem như 1 tập hợp bên trong Tx.</li>
  <li>ScriptSig: Script Signature. Nó mã hoá Public key và chữ kí của người sở hữu Bitcoin ở hiện tại.</li>
</ul>

<p>Output: là những bitcoin mới được khoá với Hash của Public Key của người nhận. Bitcoin sử dụng mô hình UTXO là Bitcoin chỉ có thể sử dụng 1 lần, sau mỗi giao dịch thì bitcoin cũ sẽ bị loại bỏ và một lượng bitcoin mới được tạo ra. Output gồm 2 phần chính:</p>
<ul>
  <li>Value: Số lượng bitcoin mà được gửi cho người nhận. (Min: 1 satoshi = 10^-8 BTC)</li>
  <li>ScriptPubKey: Là một dãy các chỉ dẫn (Như 1 hàm) mà nhận ScriptSig là Input và trả về True nếu người sở hữu hợp lệ mở khoá Bitcoin này. Ngược lại, nó trả về false.</li>
</ul>

<p>Một giao dịch có thể có nhiều Input và Output. Các input có thể từ nhiều user (gọi là MultiSig Tx), các output có thể đến nhiều user.</p>

<p>Ngoài ra, trong Tx còn có 2 phần khác là segwit và locktime.</p>

<h3 id="miner-xác-minh-một-tx-như-thế-nào">Miner xác minh một Tx như thế nào</h3>
<p>Một Tx thoả mãn khi:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPK trả về True. Tức là với điều kiện nào thì UTXO có thể được tiêu.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>TxID</td>
          <td>index: hiện ở trong tập các UTXO</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>tổng Input values &gt; tổng Output values: Không thể tiêu nhiều hơn số tiền đang có.
Sau khi 1 Tx được post lên, miners sẽ xoá UTXO tương ứng của nó trong tập.</li>
</ul>

<h2 id="các-loại-tx">Các loại Tx</h2>
<h3 id="pay-to-public-key-hash-p2pkh">Pay to public key hash (P2PKH)</h3>
<p>Trước tiên, mọi người cần hiểu về một số op codes hoạt động trong Bitcoin Script ở <a href="https://wiki.bitcoinsv.io/index.php/Opcodes_used_in_Bitcoin_Script">đây</a>. 
Giả sử Alice muốn gửi cho Bob 5BTC. Alice và Bob sẽ làm các bước sau:</p>
<ul>
  <li>Bob tạo sig : gọi Gen():  (pkB, skB)</li>
  <li>Bob tính địa chỉ bitcoin của mình bằng: addrB = H(pkB)</li>
  <li>Bob gửi addrB cho Alice</li>
  <li>
    <p>Alice tạo giao dịch Tx-fund với Output[0] là: UTXO[0]: 5, ScriptPkB với ScriptPkB là:</p>

    <p>DUP  HASH256  «addrB»  EQVERIFY  CHECKSIG</p>
  </li>
</ul>

<p>còn ở Input, Alice có ScriptSig để xác thực Bitcoin của Alice có chứa chữ ký của Alice lên Tx này, khiến cho không ai có quyền thay đổi ScriptPkB.</p>

<p>Sau đó, Bob muốn sử dụng UTXO[0] thì sẽ tạo 1 Tx-spend với ScriptSigB trong input, bao gồm «sig» và «pkB» với Sig = Sig(skB, Tx) (Tx này là Tx-spend nhưng không chứa các ScriptSig).</p>

<p>Miner có thể xác thực ScriptSigB|ScriptPkB = true và cho phép B sử dụng số tiền.
Một số lưu ý như:</p>
<ul>
  <li>Người nhận (Bob) không thể tiết lộ PkB cho đến khi UTXO được dùng (vì bảo mật).</li>
  <li>Vì tránh việc tấn công bằng cách thay đổi Sig, Sig được chuyển vào phần witness và TxID được tính bằng:               TxID = H(Tx không chứa witness).</li>
</ul>

<h3 id="pay-to-script-hash-p2sh">Pay to script hash (P2SH)</h3>
<p>Người nhận (Bob) thay vì tạo address là H(pkB) thì tạo 1 redeem script, sau đó gán địa chỉ để người gửi (Alice) chuyển qua thành H(redeem script).
Ví dụ:</p>
<ul>
  <li>ScriptPK ở UTXO: HASH160   «H(redeem script)»  EQUAL</li>
  <li>ScriptSig để tiêu: {sig1 , sig2, …, sign, redeem script}
Từ đây, người gửi (Alice) có thể thêm các điều kiện phức tạp để xác định khi nào người nhận (Bob) có thể tiêu.</li>
</ul>

<p>Reedem Script: là các điều kiện thoả mãn để có thể sử dụng UTXO như: số chữ kí tối thiểu, thời gian,…</p>

<p>Các miner xác minh bằng cách:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPk = true: Bob gửi đúng script.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ScriptSig = true: script là thoả mãn (tức là sẽ tồn tại điều kiện để Bob có thể dùng UTXO).</li>
</ul>

<h4 id="ví-dụ-multisig">Ví dụ: MultiSig</h4>
<p>Muốn dùng UTXO thì cần t/n chữ kí. Ví dụ với 2 / 3 chữ kí. Redeem Script và ScriptSig được viết như sau:</p>
<ul>
  <li>Redeem Script: 	2, PK1, PK2, PK3, 3, CHECKMULTISIG</li>
  <li>ScriptSig: 0, sig1, sig3, redeem script</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Ngoài những dạng Tx ở trên, sẽ có nhiều dạng Tx khác được sử dụng ở trong nhiều trường hợp cụ thể.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.]]></summary></entry><entry><title type="html">Cấu tạo block và PoW</title><link href="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow" rel="alternate" type="text/html" title="Cấu tạo block và PoW" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow"><![CDATA[<p>Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).</p>

<h2 id="cấu-tạo-block-trong-bitcoin">Cấu tạo block trong bitcoin</h2>
<p>Các block chứa các dữ liệu về Tx được lưu vào trong sổ cái công khai. Block có các header, nơi chứa các siêu dữ liệu giúp quản lý block đó. Kích thước blockheader là 80 bytes, trong khi các giao dịch trung bình khoảng 250 bytes và mỗi khối trung bình chứa được 500 Tx.</p>

<p>Ở trong blockheader chứa các dữ liệu liên quan đến các block đó. Đầu tiên, là giá trị hash của block liền trước nó(32 bytes), giúp đảm bảo liên kết trong chuỗi. Tiếp theo là Version (4 bytes) là phiên bản của block hiện tại. Merkle Root cũng được lưu ở đây (32 bytes), là giá trị hash của của gốc cây Merkle của các Tx. 4 bytes Timestamp là chỉ thời gian block được tạo, được tính bằng số giây từ 01/01/1970. Tiếp theo là Hash Target/ Difficult Target (4 bytes) là giá trị hash mục tiêu của PoW cho block này. Cuối cùng là số nonce (4 bytes), là giá trị mà các miner tìm để giải bài toán PoW.</p>

<h2 id="proof-of-work">Proof of Work</h2>
<p>PoW là một phần dữ liệu khó tạo (là đáp án cho một bài toán) hoặc rất tốn kém, mất thời gian để tạo nhưng chỉ tốn 1 thời gian rất ngắn (đpt O(1)) để có thể kiểm tra xem đáp án đó có đúng không. Quy trình tạo dữ liệu này là ngẫu nhiên với xác suất thấp, cần thử sau rất nhiều lần trước khi tạo ra PoW hợp lệ.</p>

<p>PoW là cách để các nodes cùng đồng thuận về tình trạng của block, tránh việc <a href="https://academy.binance.com/vi/articles/double-spending-explained">chi tiêu khép</a>, từ đó cho phép cập nhập blockchain theo các quy tắc của hệ thống.</p>

<h3 id="ví-dụ-với-bitcoin">Ví dụ với Bitcoin:</h3>
<p>Trong quá trình tạo khối, các miner sẽ phải giải được bài toán tìm số nonce để đưa vào blockheader và khiến block hợp lệ. Block hợp lệ là block có hash nhỏ hơn target value hiện tại.
Hash của block là lấy (Tổng của: Merkle Root, Version, Timestamp, Target, PreviousHash, Nonce) hash 2 lần,nếu Hash này nhỏ hơn hoặc bằng Target, tức là block này hợp lệ. Block này sau đó sẽ được đưa vào chuỗi sau khi các nodes khác verify rằng nonce này là hợp lệ (với độ phức tạp O(1)). Ngược lại, các miner sẽ phải tìm số Nonce khác.</p>

<p>Độ khó (Target Hash) sẽ được thay đổi sau 2016 block (2 tuần) được sinh ra. Nếu thời gian sinh 2016 block này nhanh hơn, Target Hash sẽ được điều chỉnh xuống, ngược lại sẽ tăng lên. Sau khi cập nhập, các nodes cùng chia sẻ một Target.</p>

<h3 id="incentive">Incentive</h3>
<p>Sau khi tạo được block, miner sẽ nhận phần thưởng và Tx phí thông qua coinbase mà họ đưa vào block. <br />
Coinbase là giao dịch đầu tiên trong block, được tạo bởi miner nhằm mục đích nhận phần thưởng và Tx phí. Do đó, coinbase không có input, chỉ có output là địa chỉ ví của miner. Bitcoin nhận được từ coinbase không thể được sử dụng cho đến khi đạt 100 xác nhận trong blockchain.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>PoW là một cơ chế đồng thuận được sử dụng ở nhiều blockchain khác nhau, tuy nhiên nó cũng mang lại nhiều bất lợi. Những cơ chế đồng thuận khác sẽ được viết ở những bài sau.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).]]></summary></entry><entry><title type="html">Kĩ thuật Blockchain</title><link href="http://localhost:4000/blog/2023/07/14/blockchain-technology" rel="alternate" type="text/html" title="Kĩ thuật Blockchain" /><published>2023-07-14T00:00:00+07:00</published><updated>2023-07-14T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/14/blockchain-technology</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/14/blockchain-technology"><![CDATA[<p>Blockchain cung cấp sự tin cây cho nhiều bên (mà không cần đến trung gian), đây là ứng dụng có thể xem là mạnh mẽ nhất của blockchain. Dưới đây, mình sẽ viết sâu hơn về các kĩ thuật được sử dụng trong blockchain.</p>

<h2 id="các-tầng-của-blockchain">Các tầng của Blockchain</h2>
<p>Blockchain có thể chia thành các tầng chính như sau:</p>
<h4 id="application-layer">Application layer:</h4>
<p>Bao gồm các DApps, Smartcontract, các phần mềm chạy trên đỉnh các network. Đây là tầng cho phép build các Apps và Service phục vụ người dùng.</p>

<h4 id="consensus-layer">Consensus layer:</h4>
<p>Là tầng mà các nodes đồng ý về tính hợp lệ của các giao dịch, dựa trên các cơ chế đồng thuận.</p>

<h4 id="network-layer">Network layer:</h4>
<p>Là tầng mà các nodes giao tiếp với nhau (P2P). Tầng này phục vụ việc kết nối, lan truyền các Tx và phân phối các dữ liệu trên mạng. Đây cũng là tầng mà các block được tạo ra và thêm vào chuỗi.</p>

<h4 id="data-layer">Data layer:</h4>
<p>Là tầng lưu trữ dữ liệu an toàn và bất biến. Các dữ liệu bao gồm sổ cái, cơ sở dữ liệu trạng thái (Hash, Merkle Tree, Tx, Chữ ký,..).</p>

<h4 id="hardware-layer">Hardware layer:</h4>
<p>Là tầng vật lý, các thiết bị như máy tính, servers, routers,…</p>

<p>Ở tầng Consensus, các nodes phải đảm bảo các tính chất sau:</p>
<ul>
  <li>Persistence: Khi các Tx và block được thêm vào chuỗi, không thể xoá bỏ</li>
  <li>Safety: Các thành viên tham gia (các nodes, người dùng) đều có chung 1 dữ liệu về sổ cái</li>
  <li>Liveness: các thành viên Honest (không phá hoại mạng blockchain) thêm được các giao dịch</li>
  <li>Open: Ai cũng có thể thêm các giao dịch.</li>
</ul>

<p>Cùng với đó, có những vấn đề xảy ra ở tầng Consensus này cần giải quyết đó chính là việc Network delays, Network Partition, Crash, Malice,.. dẫn đến danh sách các Tx có thể bị sai thứ tự, không đầy đủ,…</p>

<h2 id="mã-hoá">Mã hoá</h2>
<p>Hàm Hash H là một hàm mã hoá được sử dụng với ý nghĩa sau:
Với 2 tập hợp M và T có:  <img src="https://latex.codecogs.com/svg.image?%5Cleft%7CM%5Cright%7C%5Cgg%5Cleft%7CT%5Cright%7C" alt="a" /> thì hàm hash H: <img src="https://latex.codecogs.com/svg.image?%5Cleft%7CM%5Cright%7C%5Crightarrow%5Cleft%7CT%5Cright%7C" alt="a" />. Ví dụ khi input có giá trị lên đến cả megabyte, khi chuyển qua hàm hash H sẽ có dạng 32 bytes. <img src="https://latex.codecogs.com/svg.image?%5CLeftrightarrow%20T=%5Cleft%5C%7B0,1%5Cright%5C%7D%5E%7B256%7D" alt="a" /></p>

<p>Một hàm hash như trên gọi là chống trùng lặp nếu như rất khó để tìm ra 1 cặp (x, y) ∈ M sao cho x ≠ y mà H(x) = H(y). Hàm này còn được gọi là CRF (Collision Resistant Function).</p>

<h3 id="commit-dữ-liệu-lên-blockchain">Commit dữ liệu lên blockchain</h3>
<p>Nếu user A có file m:    <img src="https://latex.codecogs.com/svg.image?h=H(m)" alt="a" /> là cam kết ràng buộc cho m. Với một danh sách <img src="https://latex.codecogs.com/svg.image?S=(m1,m2,...mn),h=commit(S)(h=H(S))" alt="a" />. 
Khi user B đọc h, cho <img src="https://latex.codecogs.com/svg.image?(m_%7Bi%7D%5E%7B%7D,proof%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> có thể kiểm tra xem S[i] có bằng <img src="https://latex.codecogs.com/svg.image?m_%7Bi%7D%5E%7B%7D" alt="a" /> hay không.
Điều này tương đương với khi chạy hàm <img src="https://latex.codecogs.com/svg.image?verify(h,i,m_%7Bi%7D%5E%7B%7D,%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> sẽ ra 1 trong 2 kết quả: accept/reject.</p>

<p>Ngoài ra, để đảm bảm security, không thể tìm được bộ <img src="https://latex.codecogs.com/svg.image?%5Csmall%20(S,i,m,%5CPi)" alt="a" /> mà m ≠ S[i] và <img src="https://latex.codecogs.com/svg.image?verify(h,i,m_%7Bi%7D%5E%7B%7D,%5CPi%20_%7Bi%7D%5E%7B%7D)" alt="a" /> = accept.</p>

<h3 id="merkle-tree">Merkle Tree</h3>
<p>Mục tiêu của Merkle tree là khi commit danh sách S ở trên, có thể chứng minh được mi = S[i]. 
Cây merkle được xây dựng như sau:</p>

<p>// Vẽ sau</p>

<p>Các phần tử, cha của chúng là H(nó, sibling kề nó). Ví dụ y1 là H(m1, m2). Bây giờ, với bài toán chứng minh ở trên, ví dụ cần chứng minh S[4] = m4, ta chỉ cần set Proof = (m3, y1, y6).
Lý do:</p>

<p><img src="https://latex.codecogs.com/svg.image?%5Csmall%20y2%5Cleftarrow%20H(m3,m4)%5C%5Cy5%5Cleftarrow%20H(y2,y1)%5C%5Ch'%5Cleftarrow%20H(y5,y6)." alt="a" /></p>

<p>Nếu h = h’ thì accept. Khi muốn post 1 block vào trong chain, cần viết commit(S) vào. Merkle tree được sử dụng để chứng minh một Tx có ở trong block.</p>

<h2 id="chữ-kí-số">Chữ kí số.</h2>
<p>Làm cách nào mà các nodes có thể xác thực được các Tx? Thực tế, để xác định cần 3 thuật toán:</p>
<ul>
  <li>Gen(): tạo ra cặp key  (pK, sK) cho user.</li>
  <li>Sign(sK, msg): người gửi kí secretKey với msg họ muốn gửi. Output: là 1 sig: σ</li>
  <li>Verify(pK, msg, σ). Output: accept / reject</li>
</ul>

<p>Khi tạo ra các Tx, user đưa Sk + msg để tạo ra chữ kí σ. Các verifier sẽ sử dụng pK, msg và σ để verify các Tx. Việc sử dụng chữ kí số này giúp đảm bảo uỷ quyền Tx, khả năng bầu cử và sự đồng thuận bỏ phiếu của user.</p>

<h2 id="tạm-kết">Tạm kết</h2>
<p>Ở phần này là những kĩ thuật phổ biến được sử dụng trong blockchain. Trong bài tiếp theo, mình sẽ đi sâu về cấu tạo của từng khối và cách hoạt động của PoW.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Blockchain cung cấp sự tin cây cho nhiều bên (mà không cần đến trung gian), đây là ứng dụng có thể xem là mạnh mẽ nhất của blockchain. Dưới đây, mình sẽ viết sâu hơn về các kĩ thuật được sử dụng trong blockchain.]]></summary></entry><entry><title type="html">Tổng quan về Blockchain</title><link href="http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain" rel="alternate" type="text/html" title="Tổng quan về Blockchain" /><published>2023-07-14T00:00:00+07:00</published><updated>2023-07-14T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/14/tong-quan-ve-blockchain"><![CDATA[<p>Blockchain là một xu thế đang khá nổi ở thời điểm hiện tại. Theo những gì mình tìm hiểu và học hỏi được, đây là những chia sẻ tổng quan của mình về blockchain</p>

<h2 id="blockchain-là-gì">Blockchain là gì</h2>
<p>Blockchain là một sổ cái số phi tập chung ghi lại các dữ liệu giao dịch một cách an toàn, được duy trì bởi các máy tính chuyên dụng trên mạng (hay gọi là các nodes). Nó đảm bảo tính toàn vẹn bất biến thông qua cơ chế mã hoá và đồng thuận. Khi một giao dịch đã được record, nó sẽ không thể bị thay đổi.</p>

<p>Nói một cách đơn giản, blockchain như một loại cơ sở dữ liệu đặc biệt, được duy trì phi tập trung bởi nhiều máy tính phân bổ khắp thế giới. Ngoài ra, dữ liệu trên từng block sắp xếp theo trình tự thời gian, và bảo mật bằng mật mã để tránh bị làm giả dữ liệu</p>

<h2 id="sự-phi-tập-trung-trong-blockchain">Sự phi tập trung trong blockchain</h2>
<p>Trong Blockchain, quyền quyết định và điều khiển của mạng lưới thì phân bổ cho các user thay vì tập trung tại 1 user hoặc 1 tổ chức. Các giao dịch (Tx) được verified và ghi vào mạng máy tính phân tán hoạt động cùng nhau để duy trì tính toàn vẹn.</p>

<p>Ở trong core, blockchain lưu giao dịch giữa 2 bên. Khi 1 user gửi 1 Tx, nó được truyền đi khắp mạng lưới. Các nodes xác minh giao dịch bằng xác minh chữ kí số (Digital Signature) và các thông tin khác. Khi giao dịch được xác minh, nó sẽ cùng với các Tx khác được thêm vào block. Các block sẽ liên kết với nhau bằng phương pháp mã hoá, tạo thành chuỗi. Quá trình xác minh và thêm vào chuỗi sẽ được thông qua cơ chế đồng thuận.</p>

<h2 id="cơ-chế-đồng-thuận-và-mã-hoá">Cơ chế đồng thuận và mã hoá</h2>
<p>Cơ chế đồng thuận là tập hợp các quy tắc chi phối các node có đồng thuận về trạng thái của chuỗi hiện tại và tính hợp lệ của giao dịch hay không. Điều này đảm bảo các nodes trong mạng sẽ đều có bản copy đầu đủ của sổ cái.</p>

<p>Mã hoá là chìa khoá duy trì bảo mật, minh bạch và chống giả mạo của blockchain. Có 2 cách mã hoá chính được sử dụng là Hash và cặp khoá. Với Hash, là hàm không thể đảo ngược, giúp chuyển 1 input ở 1 size bất kì sang 1 size cố định. Mỗi khối trong chuỗi chứa hash của khối liền trước nó, nên khi muốn thay đổi 1 khối thì cần phải thay đổi các khối tiếp theo. Điều này giúp giảm khả năng bị thay đổi của khối xuống còn rất nhỏ. Người dùng có 1 cặp khoá Secret - Public của mình. Khi tạo 1 Tx, người đó sử dụng Secret key để kí và tạo chữ kí số. Những người khác xác nhận tính xác thực của Tx này bằng cách áp dụng Public key của người gửi.</p>

<h2 id="crypto-currency">Crypto Currency</h2>
<p>Tiền điện tử (Tiền mã hoá) là 1 loại tiền kĩ thuật số phi tập trung, sử dụng mật mã để bảo mật. Nó có thể hoạt động độc lập với các trung gian như ngân hàng, cổng thanh toán,..
Việc phi tập trung tạo điều kiện thuận lợi cho các giao dịch ngang hàng (P2P) giữa các cá nhân thông qua các ví điện tử hoặc sàn giao dịch.
Các tiền điện tử luôn nằm trong blockchain. Trong trường hợp các sàn giao dịch, nó chứa Secret key cho phép người dùng truy cập vào các tiền đó.</p>

<h3 id="crypto-currency-hoạt-động-như-thế-nào-">Crypto Currency hoạt động như thế nào ?</h3>
<p>Crypto Currency sử dụng thuật toán toán học tiên tiến để bảo mật các giao dịch và bảo vệ dữ liệu khỏi bị truy cập hoặc thao tác trái phép. Các thuật toán phục vụ 2 chức năng chính là: Duy trì quyền riêng tư của người dùng và xác minh tính xác thực của Tx.</p>

<p>Crypto whitepaper là một document mô tả chi tiết kèm các thông số kĩ thuật về 1 dự án blockchain. Các thông tin nó bao gồm rất đa dạng, có thể kể đến như: project goals, works, tech, roadmap,…</p>

<h3 id="stable-coin">Stable coin</h3>
<p>Một loại tiền điện tử được thiết kế để duy trì một giá trị cố định. Nó có thể trace giá trị tiền tệ fiat (tiền tệ được các nước sử dụng chính thức) hoặc các loại tài sản khác.</p>

<h2 id="smartcontract">SmartContract</h2>
<p>Hợp đồng thông minh là một thoả thuận kĩ thuật số được lập trình và lưu trữ trong blockchain, tự vận hành không cần trung gian. Nó có tính bảo mật, minh bạch, cung cấp cho người dùng sự tự do trao đổi, an toàn, khi triển khai các giao dịch. Hợp đồng thông minh được xem là xương sống của các DApps.
Bất cứ ai truy cập vào blockchain có thể gọi SmartContract và tương tác với nó.</p>

<h2 id="dapp">DApp</h2>
<p>Decentralized Application (DApp) là ứng dụng phi tập trung được xây dựng trên các nền tảng blockchain. Các ứng dụng này sử dụng SmartContract, và hoạt động không cần sự can thiệp của bất kì bên trung gian nào. Với DApp, mọi thứ đều được mã hoá, bất biến, an toàn, bảo mật và không ai có quyền thay đổi, lừa đảo, gian lận.</p>

<h2 id="nodes">Nodes</h2>
<p>Là các moderators xây dựng cơ sở cho mạng phi tập trung. Nó lưu trữ bản copy của sổ cái, được đồng bộ hoá và lập trình để thực hiện các giao dịch theo sự đồng thuận của đa số. Các nodes có thể là các máy tính, router,…</p>

<h2 id="tạm-kết">Tạm Kết</h2>
<p>Đây chỉ là những khái niệm cơ bản về blockchain. Ở bài sau, mình sẽ đi sâu vào cách hoạt động cụ thể của Blockchain.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Blockchain là một xu thế đang khá nổi ở thời điểm hiện tại. Theo những gì mình tìm hiểu và học hỏi được, đây là những chia sẻ tổng quan của mình về blockchain]]></summary></entry></feed>