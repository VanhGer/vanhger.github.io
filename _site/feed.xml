<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-15T14:59:24+07:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Sàn giao dịch phi tập trung</title><link href="http://localhost:4000/blog/2023/08/15/dex" rel="alternate" type="text/html" title="Sàn giao dịch phi tập trung" /><published>2023-08-15T00:00:00+07:00</published><updated>2023-08-15T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/08/15/dex</id><content type="html" xml:base="http://localhost:4000/blog/2023/08/15/dex"><![CDATA[<h2 id="khái-niệm">Khái niệm</h2>

<p><strong> Sàn giao dịch phi tập trung </strong> là loại ứng dụng phi tập trung, xây dựng với Smartcontract, cho phép users trao đổi ERC20 token hoặc NFT trực tiếp với các users khác.</p>

<h3 id="lợi-ích">Lợi ích:</h3>
<ul>
  <li>Không giữ tiền: Không có bên thứ 3 giữ tiền trung gian các giao dịch</li>
  <li>Chống kiểm duyệt: Ai gửi Tx đều có thể sử dụng</li>
  <li>Permissionless: có thể hỗ trợ bất kì asset nào.</li>
  <li>Thuận tiện: Không phải gửi tài sản trên chuỗi vào một sàn giao dịch</li>
  <li>Tính lập trình: Thanh khoản có thể xem bởi các smartcontract</li>
  <li>Tính nguyên tử:</li>
</ul>

<p><strong> Orderbook </strong> là sổ lệnh, bao gồm các lệnh bạn và mua tài sản theo từng mức giá nhất định. Cơ chế khớp lệnh này khiến lệnh của người dùng được thực thi khi giá của sổ lệnh khớp với giá người dùng mua hoặc bán.</p>

<h2 id="các-loại-dex">Các loại DEX</h2>
<h3 id="on-chain-orderbook">On-chain orderbook</h3>
<p>Market makers đặt các order lên chuỗi, người dùng sẽ điền các order này trực tiếp trên chuỗi nếu họ muốn giao dịch. Tuy nhiên, cách này sẽ gây tốn gas rất nhiều.</p>

<h3 id="off-chain-orderbook">Off-chain orderbook</h3>
<p>Market makers kí các orders ngoài chuỗi. Người dùng sẽ điền các order này rồi submit nó lên chuỗi. Cách này sẽ không tận dụng khả năng lập trình và thanh khoản sẽ không hiển thị với smartcontract.</p>

<h3 id="dutch-auctions">Dutch auctions</h3>
<p>User đặt các order lên chuỗi, giá sẽ từ từ điều chỉnh để thu hút. Market maker sẽ điền order đó khi họ thích mức giá đó. Vấn đề của cách này là điều chỉnh giá chậm</p>

<h3 id="automated-market-maker">Automated market maker</h3>
<p>Market markers sẽ đưa các tài sản vào trong 1 pool. Người dùng sẽ trade với pool đó mới mức giá được xác định bởi thuật toán.<br />
Lợi ích:</p>
<ul>
  <li>Tiết kiệm gas</li>
  <li>Dễ sử dụng, …</li>
</ul>

<h2 id="cách-automated-market-maker-amm-hoạt-động">Cách Automated market maker (AMM) hoạt động</h2>
<p>Giả sử 1 AMM có 2 loại tài sản, 1 là X (risky, ví dụ: ETH), 2 là Y (stable, ví dụ DAI). AMM lưu trữ x đồng X và y đồng Y. AMM đề nghị mua hoặc bán tài sản X ở một giá trị p nào đó.<br /></p>

<p>Giả sử, ta muốn duy trì tài sản X và Y trong pool với tỉ lệ a/b. Giả sử là 50/50
Vì p là giá trị của X nên ta thấy<br />
                    p.x = y <br />
                    &lt;=&gt; p = y / x. <br />
Khi đó, nếu ai đó bán lượng ETH (X) để lấy DAI (Y) thì x sẽ tăng và y giảm xuống. Dó đó giá trị p sẽ giảm đi.
Điều này tương đương với x, y tỉ lệ nghịch với nhau. <br />
Gọi x * y = k thì k được gọi là hằng số dự trữ.</p>

<p>Hình ảnh: ///</p>

<p>Ví dụ: Nếu pool có 10 ETH, 1000 DAI. Giá của 1 ETH = 100 DAI. <br />
Hằng số dự trữ: k = x * y = 10 * 1000 = 10000.</p>

<p>1) Giả sử user muốn đổi DAI lấy ETH. Muốn đổi 500 DAI + 0.3% phí để đổi lấy ETH.  <br />
Lúc này: y’ = 500 + 1500 = 1500. <br />
=&gt; x’ = 10000 / 1500 = 6.66 ETH. <br />
Lúc đó, user này sẽ nhận: 10 - 6.66 = 3.33 ETH =&gt; Giá p của 1 ETH = 150 DAI (Tăng giá).</p>

<p>2) Giả sử user muốn đổi ETH lấy DAI. ĐỔi 6ETH + 0.3% lấy DAI. <br />
Lúc này: x’ = 10 + 6 = 16 <br />
=&gt; y’ - 10000/ 16 = 625. User nhận 1000 - 625 = 375 DAI. <br />
Giá p 1ETH = 62.5 DAI, giảm 37.5 so với ban đầu.</p>

<h3 id="liquidity-provider">Liquidity Provider</h3>
<p>Là những người cung cấp thanh khoản cho pool, nhận lại được các Liquidity Token, tương đương với thanh khoản mà họ cung cấp. Khi người dùng đổi các tài sản trong pool, phần trăm phí sẽ được trả cho các LP này dựa vào số thanh khoản mà họ cung cấp.</p>

<p>Độ thanh khoản của pool được tính bằng công thức:  L = sqrt(k) = sqrt(x * y).</p>

<h3 id="những-điểm-cần-phát-triển-của-amm">Những điểm cần phát triển của AMM</h3>
<ul>
  <li>Phí gas</li>
  <li>Trượt giá: Biến động giá bởi các giao dịch từ người dùng</li>
  <li>Chênh lệch giá</li>
  <li>Hiệu quả sử dụng vốn</li>
</ul>

<h2 id="concentrated-liquidity">Concentrated Liquidity</h2>
<p>Để tăng hiệu quả sử dụng vốn, các LP có thể gửi thanh khoản ở mức giá trong khoảng cụ thể. Ví dụ như ở hình ảnh trên, là chuyển đường cong xy = k xuống dưới và sang trái. <br />
Lí do là vì giá trị p của thanh khoản sẽ chỉ ở trong 1 khoảng nhất định (Ví dụ DAI chỉ ở trong khoảng từ (0.95 ~ 1.05) USD). Do đó, khi PL cung cấp thanh khoản ở khoảng từ (0, ∞) thì hiệu quả sử dụng vốn của họ sẽ không được cao. Do đó, ở mỗi số sàn giao dịch, việc thanh khoản tập trung trông 1 khoảng hữu hạn là 1 vị trí. Vị trí này cần duy trì đủ dữ trữ để hỗ trợ giao dịch trong phạm vi của nó. Từ đó khiến nó hoạt động như một constant product pool với dự trữ lớn hơn trong khoảng đó. Từ đó việc sử dụng vốn sẽ có hiệu quả hơn.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Về cách các loại sàn hoạt động, mọi người có thể xem ở các whitePaper, ví dụ với Uniswap: https://uniswap.org/whitepaper.pdf.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Khái niệm]]></summary></entry><entry><title type="html">Solidity và State Trie</title><link href="http://localhost:4000/blog/2023/07/24/solidity-va-state-trie" rel="alternate" type="text/html" title="Solidity và State Trie" /><published>2023-07-24T00:00:00+07:00</published><updated>2023-07-24T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/24/solidity-va-state-trie</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/24/solidity-va-state-trie"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie</p>

<h2 id="solidity">Solidity</h2>
<p>Solidity là ngôn ngữ lập trình cho Blockchain Ethereum, là ngôn ngữ hướng đối tượng, cấp cao để triển khai các smartcontracts. Smartcontract là chương trình chi phối các hành vi của Account trong Ethereum State. Account contract được tạo ra khi chạy một smartcontract. Mọi người có thể đọc account contract state ở trong storage array, nên không bao giờ được lưu trữ các bí mật trong contract.</p>

<p>Một số dạng biến của Solidity như: uint256, address(byte 32), bool,… Các loại tham chiếu là mảng, struct, string, map,… Khi một giao dịch đi từ A ⇾ B ⇾ C ⇾ D thì tại D, msg.sender là C, nhưng tx.origin là A.</p>

<p>ERC20 là API tiêu chuẩn cho fungible token, cung cấp các chức năng cơ bản để chuyển token hoặc cho phép token được sử dụng bởi bên thứ 3.</p>

<p>Các kiểu lưu trữ:</p>
<ul>
  <li>Stack variables: Rẻ để sử dụng, phù hợp với mọi loại dữ liệu (không qua 32 bytes)</li>
  <li>Calldata: Là 1 mảng byte chỉ đọc, tốn gas</li>
  <li>Memory: 1 byte mảng, rẻ, nhưng chi phí tăng theo cấp số nhân, lưu được dữ liệu &gt; 32 bytes</li>
  <li>Storage: Đắt, mappings và các biến state lưu trong này.</li>
  <li>Event logs: rẻ, không cần truy cập đến contract.</li>
</ul>

<p>Ở trên là một số hiểu biết của mình về solidity, về mặt coding, mọi người nên xem ở <a href="https://docs.soliditylang.org/en/latest/">đây</a>.</p>

<h2 id="state-trie-ethereum-state-trie">State trie (Ethereum state trie)</h2>
<p>Hình ảnh đây là cấu trúc được tạo bởi các loại State trong Ethereum: (ở góc phải dưới hình ảnh)</p>

<p><img src="https://i.stack.imgur.com/afWDt.jpg" width="900" height=" 600" /></p>

<p>Có 3 loại state chính là World state, Transaction, và Transaction Receipt.</p>

<h3 id="world-state-trie">World State Trie</h3>
<p>World State Trie Là mapping giữa địa chỉ và Account State. Nó được update bởi các Tx, và lưu trữ mọi thông tin về accounts và có thể lấy được qua các truy vấn.
Trong World State Trie có Account Storage Trie, nơi các dữ liệu liên kết với account được lưu trữ. Nó chỉ liên quan đến các contract account và mọi dữ liệu được ánh xạ giữa các số nguyên 32 byte.</p>

<p>Account State là các thông tin về một Ethereum account, như balance, nonce, storage Root, codehash,… và là lá của World State Trie.</p>

<h3 id="transaction-trie">Transaction Trie</h3>
<p>Transaction Trie lưu trữ các Tx trong Ethereum. Khi các Tx lưu trữ trong block, nó không thể bị thay đổi. Nó được xây dựng theo cấu trúc Modified Merkel Patricia Trie, và chỉ có node root mới được đưa vào trong block.</p>

<h3 id="transaction-receipt-triereceipt-trie">Transaction Receipt Trie(Receipt Trie)</h3>
<p>Transaction Receipt Trie lưu trữ đầu ra của các Txs. Đầu ra là kết quả của một Tx mà được chạy thành công, bao gồm H(Txs), block number, gas Used, địa chỉ của contract.</p>

<h3 id="ví-dụ-cấu-trúc-của-world-state-một-cách-đơn-giản">Ví dụ cấu trúc của World State (một cách đơn giản)</h3>
<p>Để đơn giản, ta giả sử các node lá của World State Trie chỉ bao gồm địa chỉ là số dư theo cặp Key - Value. 
Các loại thông tin:</p>
<ul>
  <li>Leaf Node: node lá của cây, chứa các trạng thái của 1 tài khoản có địa chỉ là Key</li>
  <li>Branch Node: gồm 16 ô, là các tiền tố của Key.</li>
  <li>Extension Node: node chỉ có 1 child</li>
  <li>Nibble: Là phần chung trong Key, 1 Nibble = 4 bits, lưu trong keyend hoặc shared nibble.</li>
  <li>Prefixes:
    <ul>
      <li>0: extension node có số chẵn Nibble</li>
      <li>1: extension node có số lẻ Niblle</li>
      <li>2: leaf node, có số chẵn Nibble</li>
      <li>3: leaf node, có số lẻ Nibble.</li>
    </ul>
  </li>
</ul>

<p>Minh Hoạ:
World State Trie với 4 cặp Key - Value như sau:</p>
<ul>
  <li>a711355: 45 ETH</li>
  <li>a77d337: 1 WEI</li>
  <li>a7f9365: 1.1 ETH</li>
  <li>a77d397: 0.12 ETH</li>
</ul>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiSYWqaPcJtBlnFR4VAaug.png" /></p>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Ở trên là một số khái niệm sơ bộ về Solidity và cấu trúc của Ethereum, cụ thể về các State Trie.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie]]></summary></entry><entry><title type="html">Stablecoins</title><link href="http://localhost:4000/blog/2023/07/24/stable-coins" rel="alternate" type="text/html" title="Stablecoins" /><published>2023-07-24T00:00:00+07:00</published><updated>2023-07-24T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/24/stable-coins</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/24/stable-coins"><![CDATA[<p>Stable coin là 1 loại tiền điện tử được tạo để giao dịch với một giá trị không đổi. Mục đích sinh ra Stablecoin là tích hợp tiền tệ trên thế giới thật vào các ứng dụng trên chuỗi và cho phép những người không thể có USD nắm giữ và giao dịch 1 tài sản tương đương.</p>

<h2 id="custodial-stablecoin-stablecoin-kí-gửi">Custodial Stablecoin: Stablecoin kí gửi</h2>
<p>Custodian giữ kho bạc trong 1 ngân hàng truyền thống, mọi giao dịch đều thông qua nó. Ngoài ra, nó có quyền mạnh mẽ như kiểm duyệt khác hàng rút tiền hoặc xoá số dư người dùng. Điều này sẽ nguy hiểm nếu chẳng may bị hack hoặc nhầm lẫn và không đảm bảo sự phi tập trung. Do đó, cách này không được ưu tiên và sử dụng ở thực tế.</p>

<h2 id="synthetic">Synthetic</h2>
<p>Mục tiêu là xây dựng 1 loại non-custodial stablecoin. Tuy nhiên, có một vấn đề là ETH thường xuyên dao động, không ổn định so với USD.<br />
<strong> Maker DAO: </strong>  xây dựhng một stablecoin từ tài sản không ổn định. <br />
Hệ thống MakerDAO:</p>
<ul>
  <li>DAI: stablecoin (giá: 0.99 ~ 1.01 USD)</li>
  <li>MKR:
    <ul>
      <li>ai cũng có thể mua để kiếm lãi.</li>
      <li>Sử dụng để quản trị, ổn định giá DAI trong trường hợp khẩn cấp.</li>
    </ul>
  </li>
</ul>

<h3 id="đúc-dai">Đúc DAI</h3>
<p>Giả sử: A muốn trả B bằng DAI nhưng A chỉ có 1 ETH. A sẽ tạo 1 vault trên MakerDAO contract:</p>
<ul>
  <li>1 wallet: tài sản mà A kiểm soát.</li>
  <li>1 vault: tài sản mà A khoá để vay DAI.</li>
</ul>

<p>Ta có:</p>
<ul>
  <li>Ban đầu, A có: 1ETH, 0DAI trong wallet, 0ETH, 0DAI trong vault.</li>
  <li>Khi A khoá 1 ETH vào vault: trong wallet sẽ không còn ETH, trong vault có 1ETH</li>
  <li>Việc khoá ETH xem như một cách thế chấp để vay DAI. Vì số lượng thế chấp = 130% số lượng tối đa có thể vay, nên khi A thế chấp 1 ETH (~3000USD) thì chỉ có thể vay tối đa 2300 DAI.</li>
  <li>Do đó, trong wallet A có 2300DAI, còn vault: 1ETH, -2300DAI.</li>
  <li>A trả cho B bằng DAI, và có thể trả nợ cho vault để lấy lại 1 ETH.</li>
</ul>

<h3 id="stabilization">Stabilization</h3>
<p>A khi thế chấp ETH và vay DAI, phải trả lãi: Phí ổn định. Hầu hết các phí đều đưa cho DAI holders (thông qua DSR), một số còn lại đưa cho MKR holders.</p>

<p><strong> The DAI saving rate (DSR)</strong> <br />
Bất kì ai giữ DAI có thể khoá DAI của mình trong MakerDAO contract. DSR là tỉ lệ lãi từ DAI đã khoá ở trên contract. Users có thể rút DAI ra từ contract bất cứ lúc nào.</p>

<p><strong> Cơ chế ổn định: </strong> <br /></p>
<ul>
  <li>DAI có giá trị &lt; 1$  ⇒ tăng phí ổn định và DSR:
    <ul>
      <li>Người đúc DAI được khuyến khích hoàn trả món nợ đã vay sớm vì lãi đang tăng</li>
      <li>Khuyến khích DAI holders gửi nhiều DAI vào contract</li>
      <li>Từ đó giúp giảm nguồnn cùng DAI, giúp DAI tăng giá</li>
    </ul>
  </li>
  <li>DAI có giá trị &gt; 1$  ⇒ giảm phí ổn định và DSR.</li>
</ul>

<h3 id="thanh-toán">Thanh toán</h3>
<p>Nếu vault debt vượt quá 130% (do lãi), thì tài sản thế chấp sẽ được bán đấu giá. (Tiền lãi - phí) sẽ được trả nợ vault cho A đến khi đạt dưới 130%.</p>

<h2 id="nfts">NFTs</h2>
<p>NFTs là:</p>
<ul>
  <li>Quyền sở hữu token của 1 tài sản kĩ thuật số (như Digital Artwork, vitual games item,…).</li>
  <li>Không thể có NFT nào giống nhau, nên không thể trao đổi lẫn nhau.</li>
  <li>Được xác định bởi lịch sử, mức độ tiện ích, tầm quan trọng,…</li>
</ul>

<h3 id="sở-hữu-tài-sản-kĩ-thuật-số">Sở hữu tài sản kĩ thuật số</h3>
<p>NFTs hoạt động như một chứng thư pháp lý:</p>
<ul>
  <li>Có thể chuyển quyền sở hữu từ bên này sang bên khác</li>
  <li>Quyền sỏ hữu thể hiện tình trạng sở hữu tài sản, cấp quyền hợp pháp,…</li>
</ul>

<h3 id="nhận-nfts-như-thế-nào">Nhận NFTs như thế nào</h3>
<p>Có 2 cách chính là tìm người sở hữu và mua từ học, hoặc lên thị trường và mua.</p>

<h3 id="thị-trường-nft">Thị trường NFT</h3>
<p>Được xây dựng như một tập các smartcontract, thành một hệ thống tài sản và trao đổi. NFT mang lại sự sở hữu đích thực trên Internet, kích hoạt thương mại kĩ thuật số,… Ví dụ: một số NFT đặc biệt mang lại cho người dùng sự truy cập vào một số IP, trang trên Internet.</p>

<h3 id="nft-cost-issue">NFT cost issue:</h3>
<p>Đa phần các NFT đều có giá cao, do đó muốn sở hữu thì có thể thuê hoặc tiết kiệm. Sẽ khó bắt đầu kinh doanh NFT nếu không có tiền mặt hoặc nguồn cung cấp đủ lớn.</p>

<p>Một số dịch vụ dựa trên NFTs như: Gameing guild (các item trong game: NFTs), EveryRealm (Bất động sản ảo), Credit Provider,…</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Stable coin là 1 loại tiền điện tử được tạo để giao dịch với một giá trị không đổi. Mục đích sinh ra Stablecoin là tích hợp tiền tệ trên thế giới thật vào các ứng dụng trên chuỗi và cho phép những người không thể có USD nắm giữ và giao dịch 1 tài sản tương đương.]]></summary></entry><entry><title type="html">Cơ chế Ethereum</title><link href="http://localhost:4000/blog/2023/07/23/ethereum-mechanics" rel="alternate" type="text/html" title="Cơ chế Ethereum" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/ethereum-mechanics</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/ethereum-mechanics"><![CDATA[<p>Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội</p>

<h3 id="so-sánh-chung">So sánh chung</h3>
<p>Bitcoin như một máy chuyển trạng thái. Bitcoin rule: S x I ⇾ S, với tập S là các trạng thái, I là tập tất cả các input. Còn với Ethereum, hàm chuyển trạng thái của nó sẽ phong phú hơn nhiều, và mỗi lần chuyển đổi thì sẽ thực hiện toàn bộ chương trình.</p>

<p>Ethereum hỗ trợ các DApp, với Program code được lưu trữ trên blockchain, khi chạy cũng sẽ thay đổi các trạng thái. Các block thì sẽ có khoảng 150 Tx, và các Block Proposer sẽ nhận Tx fee cho block và các phần thưởng khác khi tạo khối thành công.</p>

<p>Ngoài ra, ta đã biết rằng khi các block được proposer trong consensus layer (các beacon block, nên còn được gọi là beacon chain), các node gửi các Tx lên cho execution client hay còn gọi là compute layer để cập nhập các trạng thái (update world state).</p>
<h2 id="compute-layer">Compute layer</h2>
<p>World state: tập hợp các tài khoản được xác định bởi các địa chỉ 32 byte (Các thông tin như địa chỉ, số dư,..)</p>

<p>Có 2 loại tài khoản:</p>
<ul>
  <li>Owned account: Điều khiển bởi các cặp (Pk, Sk), hay là tài khoản của người dùng.</li>
  <li>Contracts: Điều khiển bởi code, được tạo lúc tài khoản được tạo, không thể thay đổi.</li>
</ul>

<p>Các dữ liệu cần thiết với mỗi account:</p>

<table>
  <thead>
    <tr>
      <th>Account Data</th>
      <th>Owned</th>
      <th>Contracts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>address(tính)</td>
      <td>H(Pk)</td>
      <td>H(CreatorAdd, CreatorNonce)</td>
    </tr>
    <tr>
      <td>storage root</td>
      <td>Không</td>
      <td>StorageRoot</td>
    </tr>
    <tr>
      <td>code</td>
      <td>không</td>
      <td>CodeHash</td>
    </tr>
    <tr>
      <td>balance</td>
      <td>balance</td>
      <td>balance</td>
    </tr>
    <tr>
      <td>nonce</td>
      <td>nonce</td>
      <td>nonce</td>
    </tr>
  </tbody>
</table>

<p>Trong đó, nonce là số Tx mà acount đã thực hành, tính bằng (#Tx sent) + (#accounts created). Số nonce được dùng để chống replay và khi tạo mới thì luôn bằng 0 (với contract).  Các contract có thể bị ghi đè code, nhưng chỉ khi contract cũ đã SELFDESTRUCT.</p>

<p>Mỗi contract có 1 mảng lưu trữ liên quan gồm 2^256 phần tử, mỗi phần tử là 32 bytes. Và storage root là Merkle Patricia hash của mảng.</p>

<h3 id="chuyển-trạng-thái">Chuyển trạng thái</h3>
<h4 id="tx">Tx</h4>
<ul>
  <li>Được kí bởi người tạo.</li>
  <li>To: nếu = 0 là tạo account mới, code = (init, body). Còn lại là 32-bytes địa chỉ và data (những thứ mà contract gọi và các đối số).</li>
  <li>From: Địa chỉ khởi tạo và chữ kí vào Tx</li>
  <li>Value: số Ethereum được gửi.</li>
  <li>Tx fees: gasLimit, maxFee, maxPriorityFee (Sẽ nói rõ hơn ở phần sau).</li>
  <li>Nonce: Khớp với nonce hiện tại của người gửi, tránh việc replay Tx.</li>
  <li>Chain-id: đảm bảo giao dịch gửi đúng chuỗi (không thể dùng giao dịch testnet lên mainnet).</li>
</ul>

<h4 id="các-loại-tx">Các loại Tx</h4>
<ul>
  <li>owned ⇾ owned: chuyển ETH giữa các user</li>
  <li>owned ⇾ contract: gọi contract với ETH &amp; data</li>
</ul>

<h4 id="messages">Messages</h4>
<p>Là các Tx ảo được contract tạo ra, nó không có Signature (vì contract không có). Có 2 loại là:</p>
<ul>
  <li>contract ⇾ onwed: contract gửi tiền cho user</li>
  <li>contract ⇾ contract: contract gọi contract khác.</li>
</ul>

<h3 id="ethereum-block">Ethereum block</h3>
<p>Khác với Block của Bitcoin, Block Header của Ethereum có nhiều loại dữ liệu hơn, một số chính như:</p>
<ul>
  <li>Consensus data: các dữ liệu như Proposer Id, Previous hash, vote,…</li>
  <li>Address: Nơi mà gas fee được chuyển đến</li>
  <li>World state root: Merkle Patricia Tree Hash của tất cả các tài khoản</li>
  <li>Tx root: Merkle Tree Hash của Tx</li>
  <li>Tx receipt root: Merkle Hash của các log message</li>
  <li>Gas used: Sử dụng để điều chỉnh giá gas (ở phần sau).</li>
</ul>

<h3 id="evm-mechanics">EVM mechanics</h3>
<p>EVM là môi trường thực thi (execution). Các contract được viết bằng solidity, sau đó sẽ được compile thành EVM bytecode và được các validator sử dụng để chạy các contract. <br />
EVM hoạt động như một [Stack Machine] (https://en.wikipedia.org/wiki/Stack_machine) với lệnh JUMP (Các program sẽ bị huỷ nếu quá stack, proposer giữ lại gas).</p>

<h3 id="gas">Gas</h3>
<p>Gas được xem như là nguyên liệu của Ethereum, là khoản phí cần trả để thực hiện các giao dịch hay hoạt động tương tác với smartcontract. Mọi chỉ thị đều tốn gas, giúp ngăn việc gửi Tx có nhiều bước (tốn nhiều tiền hơn). Các Proposer có thể chọn các Tx từ mempool có phí gas cao để tối đa hoá thu nhập.</p>

<h4 id="gas-calculation">Gas calculation:</h4>
<p>Mỗi block có:</p>
<ul>
  <li>baseFee: gasPrice nhỏ nhất cho tất cả Tx trong block. BaseFee dựa vào tổng số gas ở block trước (Gas used ở header), nếu gasUsed là giới hạn (30M) thì baseFee tăng 12.5%, nếu block trước trống thì giảm 12.5%. Còn lại thì giữ nguyên.</li>
  <li>gasLimit: tổng gas cho phép với Tx</li>
  <li>maxFee: giá gas tối đa cho phép</li>
  <li>maxPriorityFee: ‘tips’ tối đa cho Proposer.</li>
</ul>

<p>GasPrice = min(maxFee, baseFee + maxPriorityFee) <br />
MaxTxFee = gasLimit x gasPice <br />
<strong> Cụ thể </strong></p>
<ul>
  <li>nếu gasPrice &lt; baseFee: dừng</li>
  <li>nếu MaxTxFee &gt; sender.balance: dừng</li>
  <li>trừ MaxTxFee khỏi sender.balance</li>
  <li>Đặt Gas = gasLimit</li>
  <li>Chạy Tx, trừ gas từ Gas với mỗi Tx. Nếu Gas &lt; 0 thì dừng, Proposer giữ gasLimit * gasPrice.</li>
  <li>Xong xuôi, trả lại Gas x gasPrice cho sender</li>
  <li>gasUsed = gasLimit - Gas. BURN gasUsed x baseFee và gửi gasUsed x (GasPrice - baseFee) cho block proposer.</li>
</ul>

<p>ETH bị BURN vì giúp giảm lạm phát, tăng tính khan hiếm, có lợi cho nhà đầu tư, chặn các proposer tạo ra các Tx giả, không khuyến khích các thoả thuận ngoài chuỗi.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Ở trên là toàn bộ hiểu biết của mình về cơ chế Ethereum.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội]]></summary></entry><entry><title type="html">Proof Of Stake</title><link href="http://localhost:4000/blog/2023/07/23/proof-of-stake" rel="alternate" type="text/html" title="Proof Of Stake" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/proof-of-stake</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/proof-of-stake"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.</p>

<h3 id="accountable-safety">Accountable Safety</h3>
<p>Một giao thức với resilence là n/3 khi giao thức đó an toàn nếu nó có ít hơn n/3 Adverserial node (Ví dụ streamlet). <br />
Một giao thức với Accountable Safety resilence n/3 là giao thức:</p>
<ul>
  <li>An toàn nếu ít hơn Adverserial node.</li>
  <li>Nếu vi phạm safety, thì những người giám sát (các node không phải người được chọn để đề xuất khối) có thể xác định rõ các node vi phạm.</li>
  <li>Không có cáo buộc sai với các node trung thực.</li>
</ul>

<h3 id="finality-và-dynamic-availability">Finality và Dynamic availability</h3>
<p>Gọi một giao thức là finality nếu nó duy trì safety trong thời gian không đồng bộ (trước GST). Ở các giao thức này, Tx được finalize nhanh hơn confirm trong bitcoin (60 phút). <br />
Gọi một giao thức là Dynamic availability nếu giao thức đó có thể tiếp tục confirm các giao dịch ngay cả khi nhiều node offline.</p>

<p>Không có giao thức SMR nào đảm bảo cung cấp cả 2. Do đó, một cách giải quyết là sử dụng Nested chains.</p>

<h3 id="nested-chains">Nested chains</h3>
<ul>
  <li>Available chain được xác định bởi giao thức Π_ava, thoả mãn Dynamic availability (VD: Nakamoto consensus).</li>
  <li>Finalized chain được xác định bởi giao thức checkpoint Π_fin thoả mãn security dưới mạng đồng bộ 1 phần.</li>
  <li>Chuỗi confirm bởi Π_ava là available chain.</li>
  <li>Π_fin kiểm tra các block trong availbale chain.</li>
  <li>Tiền tố của checkpoint cuối cùng tạo thành finalized chain. Tương đương với Finalized chain là prefix của available. Chuỗi này safe dưới mạng bất đồng bộ</li>
  <li>Các block của available chain luôn extend từ điểm checkpoint cuối cùng.</li>
</ul>

<p>Minh hoạ: hình ảnh</p>

<h2 id="proof-of-stake">Proof of Stake</h2>
<h3 id="tổng-quan">Tổng quan:</h3>
<ul>
  <li>Trong giao thức Pos, các nodes khoá (Stake) tiền của họ trong giao thức để đủ điều kiện tham gia consensus.</li>
  <li>Càng nhiều coin được stake bởi 1 node thì khả năng cao node đó được chọn làm validator. Vì thuật toán lựa chọn validator là giả ngẫu nhiên.</li>
  <li>Nếu node bị bắt quả tang thực hiện 1 hành động bất lợi (xác thực giao dịch sai) thì node đó sẽ bị burn số tiền đã stake và không thể tham gia vào quá trình đề xuất khối tiếp theo. (Slashing).</li>
</ul>

<p>Do đó, trong PoS, nodes sẽ có trách nhiệm trong cách hành động của mình. PoS giúp thay đổi cơ chế block được verify. Ngoài ra, để trở thành validator, các node phải có điều kiện (ví dụ: có ít nhất 32 ETH,..), sau khi đóng 1 khối, khối đó sẽ được các validator khác validate theo nhiều method khác nhau tuỳ vào blockchain.</p>

<h3 id="cụ-thể-với-ethereum-20">Cụ thể với Ethereum 2.0</h3>

<h4 id="chọn-validator-và-block-proposer">Chọn Validator và Block Proposer</h4>
<p>Để thành một validator, phải gửi ít nhất 32 ETH vào contract và chạy 3 phần mềm riêng biệt (sẽ giới thiệu ở sau) và tham gia hàng đợi. Thời gian của blocks chia thành các slot: 12s, epoch: 32 slot. Sau khi được active, validator đó sẽ tham ra vào quá trình phê duyệt. 1 validator ngẫu nhiên sẽ được chọn để xác thực giao dịch và đề xuất khối ở mỗi slot (Block proposer). Số còn lại sẽ làm giám sát để phê duyệt và kiểm tra xem validator đó có gian lận không.</p>

<p>Chọn Block Proposer quá trình giả ngẫu nhiên gồm nhiều yêu tố như staking age, số tiền stake,… Ở đây, mình sẽ giới thiệu 2 phương pháp lựa chọn là:</p>
<ul>
  <li><strong> Randomize block selection: </strong> lựa chọn bằng cách tìm kiếm nodes có sự kết hợp của hash value thấp nhất và stake cao nhất. Vì size của các stakes là công khai nên có thể dự đoán được.</li>
  <li><strong> Coin Age Selection: </strong> là phương thức chọn các nodes dựa vào khoảng thời gian stake. Coin Age được tính bằng: số ngày đặt cược x số lượng coin. Khi một node forge một block, coin age của nó được cài về 0.</li>
</ul>

<h4 id="quy-trình-xác-thực">Quy trình xác thực</h4>
<p>Khi một user tạo Tx và submit lên Ethereum, nó sẽ được kiểm tra tính hợp lệ (Ví dụ đảm bảo số tiền, key đúng,…) sau đó được đưa đến mempool và phát tán nó đến các node khác. <br />
Một node được chọn làm Block Proposer để đề xuất khối ở slot này, có trách nhiệm đóng và phát tán block vào chuỗi và cập nhập trạng thái. Nodes chạy 3 phần mềm:</p>
<ul>
  <li>Execution client: gộp các Txs từ mempool thành “execution payload” và chạy nó ở local để tạo ra sự thay đổi trạng thái. Thông tin này được chuyển đến consensus client</li>
  <li>Consensus client: đóng gói payload thành 1 phần của “beacon block” (gồm payload, slashing,…) cho phép mạng thống nhất trình tự về các khối.</li>
  <li>Validator client: Các node nhận được beacon block qua tầng gossip network. Sau đó chuyển đến Execution client của nó để chạy lại, nhằm chắc chắn trạng thái là đúng. Sau đóm Validator client sẽ chứng thực khối đó hợp lệ và là khối tiếp theo trong góc nhìn của chuỗi (available chain). Khối cũng được thêm vào cơ sở dữ liệu local của các node.</li>
</ul>

<h4 id="finality">Finality</h4>
<p>Như đã nói ở trên, các block của available chain luôn extend từ điểm checkpoint cuối cùng. Checkpoint là các block đầu tiên ở mỗi epoch. Các validators có thể vote cho cặp checkpoint (1 epoch), nếu ít nhất 2/3 vote cho nó, cặp checkpoint này sẽ được cập nhập, và các block nằm giữa sẽ được cập nhập thành finalized chain. Nếu chuỗi không thể finalized trong nhiều hơn 4 epoch liên tục, stake ETH từ các validator chống lại đa số sẽ bị biến mất, cho phép đa số chiếm hơn 2/3 và finalized chuỗi.</p>

<h2 id="lời-kết">Lời kết</h2>
<p>Ở trên là cách hoạt động cơ bản của POS. Mọi người có thể xem thêm các thông tin về POS trong Ethereum tại <a href="https://ethereum.org/vi/developers/docs/consensus-mechanisms/pos/">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.]]></summary></entry><entry><title type="html">Đồng thuận trên mạng</title><link href="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang" rel="alternate" type="text/html" title="Đồng thuận trên mạng" /><published>2023-07-22T00:00:00+07:00</published><updated>2023-07-22T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang"><![CDATA[<p>Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.</p>

<h2 id="bitcoin-mining">Bitcoin Mining</h2>
<p>Bitcoin chọn các nodes tham gia vào giao thức bằng các sử dụng POW, giải bài toán tìm số nonce (xem chi tiết <a href="http://127.0.0.1:4000/blog/2023/07/20/cau-tao-block-va-pow">tại</a>). 
Bitcoin sử dụng Nakamoto consensus: <br /> 
<strong> Quy tắc đề xuất: </strong> ở thời điểm nào, mỗi miner trung thực mở rộng chuỗi nặng nhất (với độ khó cao nhất).
<strong> Quy tắc confirmation: </strong> Miner confirm 1 block (với tiền tố của nó) mà ở độ sâu k trong chuỗi nó nhìn được.</p>
<ul>
  <li>Ví dụ trong thực tế: k = 6.</li>
  <li>Miner và client chấp nhận các Tx ở block cuối cùng được confirm và tiền tố của nó như là log.</li>
  <li>Leader được chọn bởi POW.</li>
</ul>

<p>So sánh giữa Bitcoin và Streamlet /// ảnh <br /></p>
<ul>
  <li>Streamlet thì không dynamic available: Nó sẽ không đảm bảo liveness nếu n/3 hoặc hơn các nodes offline.</li>
  <li>Bitcoin thì dynamic available: tiếp tục confirm Tx khi miningpower offline. <br /></li>
</ul>

<h2 id="consensus-ở-internet">Consensus ở Internet</h2>
<p>Các nodes tham gia mở, tức là các adversary có thể tạo nhiều node và người tham gia trung thực có thể online hoặc offline và đi tuỳ ý. Do đó, mục tiêu đặt ra là phải hạn chế sự tham gia của Adversary, đồng thời duy trì dynamic available của giao thức.</p>

<h2 id="security">Security</h2>
<p>Bitcoin đảm bảo an toàn dưới mạng đồng bộ, với tỉ lệ mining power do Adversary kiểm soát 𝜷 &lt; 1/2</p>

<h3 id="nakamotos-private-attack-𝜷--12">Nakamoto’s Private Attack: 𝜷 ≥ 1/2</h3>
<p>Khi adversay đào block mới, nhưng không công bố. Các miner trung thực tiếp tục đào mà không biết về các block ẩn này. Khi adversary công bố chuỗi đó (đã tạo đủ block), chuỗi đó trở thành chuỗi dài hơn chuỗi mà miners trung thực đào được (vì 𝜷 ≥ 1/2), các block đào bởi các miner trung thực sẽ bị bỏ.</p>
<h3 id="forking">Forking</h3>
<p>Vì Network delay, các honest blocks ở cùng 1 độ cao. Do đó, tỉ lệ phát triển các khối honest sẽ chậm hơn so với 1 - 𝜷. Do đó, Adversary sẽ thành công nếu 𝜷 ≥ (1 - 𝜷) / 2 (Trường hợp chỉ có 2 chuỗi fork).</p>
<h3 id="security-1">Security</h3>
<p>Nếu 𝜷 &lt; 1/2, tồn tại tỉ lệ Mining đủ nhỏ 𝜆(Δ,𝛽) = 𝜆A + 𝜆H mà Bitcoin thoả mãn security với tỉ lệ lỗi chấp nhận là 𝑒^(−Ω(𝑘)) dưới mạng đồng bộ. Đây là xác xuất lỗi với comfirmation. Đây chính là lý do sau 10 phút mới tạo ra khối mới chứ không phải là 1 giây.</p>

<h4 id="chứng-minh">Chứng minh</h4>
<p>Nhận thấy, với các khối trung thực được tạo, vẫn có thể tạo ra fork vì khối sau được tạo ra quá gần khối trước (&lt; Δ). Lúc này, khối tạo sau được gọi là Tailgater. Ngược lại, nếu khối được tạo ở thời điểm t, và không tồn tại khối nào được tạo trong khoảng thời gian từ t - Δ đến t, thì khối đó được gọi là Non-Tailgater. Các khối Non-Tailgater thì có độ cao riêng biệt nhau.</p>

<p>Giờ, ta cần tìm tỉ lệ các khối trung thực là Tailgater hoặc Non-Tailgater. Xem thời gian tạo các khối là biến ngẫu nhiên Poisson, thì khoảng thời gian T giữa 2 khối tuân theo phân bố mũ. <br /> 
Gọi mining rate là λ (1/ minutes). Với Bitcoin λ = 1/10.<br />
Theo phân bố mũ, xác suất để T lớn hơn s bất kì là: P[T &gt; s] = 𝑒^(-λs). Suy ra, nếu s = Δ thì tỉ lệ honest block tạo ra là Non-Tailgater là g = P[T &gt; Δ] =  𝑒^(-λΔ), Tailgater là 1 - g.</p>

<p>Ta thấy, các Non-tailgater block tăng với tỉ lệ: gλ, các block này có height khác nhau, vì thế chuỗi dài nhất cũng tăng ít nhất với tỉ lệ này. =&gt; liveness.</p>

<p>Với Safety, ta cần thêm các khái niệm sau:</p>
<ul>
  <li>Block B được đào ở thời gian t, nếu không có honest block nào khác được đào từ t−Δ đến t+Δ thì B gọi là loner. Do đó, loner là block duy nhất ở độ cao đó. <br />
Để vi phạm safety, cần phải có hai chuỗi khác nhau hơn k khối, cả hai đều được thông qua bởi các node trung thực. Điều này tương đương với các Adversary phải khai thác các khối nhanh hơn các khối loner được tạo ra. Gọi tỉ lệ mine của Adversary là 𝜷. Tỉ lệ mine loner là g * g * λ. <br /> Do đó, Nakamoto đảm bảo security nếu g * g * λ &gt; 𝜷.</li>
</ul>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Nếu mọi người muốn xem chi tiết về cách chứng minh, hãy truy cập vào <a href="https://eprint.iacr.org/2019/943.pdf">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.]]></summary></entry><entry><title type="html">Bitcoin Scripts và Ví</title><link href="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet" rel="alternate" type="text/html" title="Bitcoin Scripts và Ví" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/bitcoin-scripts-and-wallet</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet"><![CDATA[<p>Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.</p>

<h3 id="một-số-lưu-ý">Một số lưu ý</h3>
<ul>
  <li>Các Tx sau khi thêm vào khối sẽ không thể bị xoá, do đó khi Tx nhầm thì sẽ bị khoá hoặc mất tiền.</li>
  <li>Các TxID là độc nhất, vì Input của chúng là độc nhất. Có trường hợp ngoại lệ là các Coinbase vì chúng không có input. Do đó có thể có trùng TxID. Vì vậy, người ta thường thêm Block Height và mỗi ScriptPk của coinbase.</li>
</ul>

<h2 id="ví-dụ-về-các-loại-bitcoin-scripts">Ví dụ về các loại Bitcoin Scripts</h2>
<h3 id="bảo-vệ-tài-sản-với-co-signatory">Bảo vệ tài sản với co-signatory</h3>
<p>addr = 2 - of - 2 (PkA, PkS) với PkS là của custody server.</p>

<h3 id="escrow-service">Escrow Service</h3>
<p>Giả định: A muốn mua balo từ B với giá 0.1 BTC, nhưng A chỉ có thể trả tiền khi balo đến, và không thể không trả. Do vậy, addr có dạng: 2-of-3 (PkA, PkB, PkJ).</p>

<p>Cách vận hành:</p>
<ul>
  <li>A thông báo cho B rằng muốn mua balo với giá 0.1 BTC</li>
  <li>A post 1 Tx 0.11 BTC đến addr trên (0.01BTC để đảm bảo A sẽ trả tiền cho B).</li>
  <li>B khi thấy Tx, gửi balo cho A</li>
  <li>Khi A nhận, gửi SigA trong Tx trên cho B</li>
  <li>B sẽ sử dụng SigA và SigB để lấy số tiền mà A gửi lên Addr.</li>
</ul>

<p>Nếu vi phạm xảy ra:</p>
<ul>
  <li>B không đưa balo, A sẽ lấy lại tiền với sự trợ giúp của Judge (PkJ).</li>
  <li>A không đưa SigA, B sẽ lấy tiền với sự giúp đỡ của Judge, A mất thêm 0.01BTC.</li>
</ul>

<h2 id="ví">Ví</h2>
<p>Ví giúp user tạo ra các cặp Pk- Sk, tạo ra và xác minh các Tx, đưa ra số dư mà user có.</p>

<h3 id="giúp-đơn-giản-hoá-xác-minh-thanh-toán">Giúp đơn giản hoá xác minh thanh toán</h3>
<p>Để xác minh một thanh toán đã thực hiện, ví thường tải các block headers. Sau đó, ví gửi lên server danh sách các địa chỉ mà ví đang nắm giữ. Sau đó, server sẽ gửi về ví các Tx liên quan đến địa chỉ và Merkle Proof của Tx đó. Từ đó giúp ví hiển thị đúng số dư và xác minh Tx.</p>

<h3 id="vấn-dề">Vấn dề</h3>
<ul>
  <li>Để giải quyết được yếu tố bảo mật, blockheader sẽ được tải từ 10 servers khác nhau hoặc từ 1 nodes tin cậy.</li>
  <li>Remote server có thể kiểm tra xem addr gửi lên có thuộc về ví hay không.</li>
</ul>

<h3 id="các-loại-ví">Các loại ví</h3>
<h4 id="hot-wallet">Hot wallet</h4>
<ul>
  <li>Dạng ví điện tử có kết nối Internet, có nhiều chức năng như lưu trữ, gửi nhận Tx, tokens,…</li>
  <li>Có thể truy cập từ các thiết bị Internet như máy tính, điện thoại,..</li>
  <li>Có thể bị hack hoặc xâm nhập bởi các hacker.</li>
</ul>

<h3 id="cold-wallet">Cold wallet</h3>
<ul>
  <li>Không cho phép kết nối Internet.</li>
  <li>Có thiết bị riêng cho cold wallet, thiết bị này phải được khởi động bất cứ khi nào sử dụng và người dùng phải sao chép vật lý dữ liệu từ online device sang offline và ngược lại.</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Có nhiều loại Bitcoin Script khác như CrossChain,… được sử dụng rất phổ biến ở hiện tại.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.]]></summary></entry><entry><title type="html">Cơ bản về đồng thuận</title><link href="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus" rel="alternate" type="text/html" title="Cơ bản về đồng thuận" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus"><![CDATA[<p>Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. 
Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.</p>

<h2 id="tác-hại-của-adversary">Tác hại của Adversary</h2>
<p>Có thể gây:</p>
<ul>
  <li>Lỗi crash: Nếu các nodes này không gửi và nhận các msg (message)</li>
  <li>Lỗi bỏ sót: Nếu các nodes này chọn hoặc bỏ qua các msg</li>
  <li>Lỗi Byzantine: Các node sai có thể đi lệch khỏi giao thức.</li>
</ul>

<p>Có 2 loại adversary</p>
<ul>
  <li>Static: phá huỷ node mà nó chọn trước khi bắt đầu giao thức.</li>
  <li>Adaptive: có thể phá huỷ các node khi giao thức xảy ra.
<br />
Giới hạn sức mạnh của adversary là số node:  f. Ví dụ: f &lt; n/2, f &lt; n/3.</li>
</ul>

<h2 id="các-nodes-giao-tiếp-với-nhau">Các nodes giao tiếp với nhau</h2>
<p>Các nodes gửi các tin nhắn (message) cho nhau trong giao thức. Giả sử một node adversary đang điều khiển việc gửi tin nhắn:</p>
<ul>
  <li>Trong một mạng đồng bộ: Adversary phải chuyển tin nhắn bất kì trong thời gian Δ giây (Δ đã biết).</li>
  <li>Trong mạng không đồng bộ: Adversary có thể hoãn msg trong 1 khoảng thời gian hữu hạn, nhưng cuối cùng vẫn phải chuyển.</li>
  <li>Trong mạng đồng bộ 1 phần: tồn tại 1 sự kiện gọi là GST mà: Một msg gửi bởi 1 honest node ở thời gian t sẽ đến với người nhận trong khoảng thời gian:  Δ + Max(t, GST). 
<br />
Điều này tương đương với mạng sẽ không đồng bộ cho tới GST, sau đó sẽ đồng bộ</li>
</ul>

<h3 id="state-machine-replication-smr">State Machine Replication (SMR)</h3>
<p>Là phương pháp chung để triển khai dịch vụ chịu lỗi bằng việc sao chép máy chủ và điều phối tương tác của máy client với bản sao đó. Nó cung cấp framework để hiểu và thiết kết giao thức quản lý sao chép.</p>

<p>SMR gồm 2 phần:</p>
<ul>
  <li>Replicas: Nhận Tx, chạy giao thức SMR và xác định log. Các Log(Ledger) là chuỗi Tx thứ tự tuyến tính.</li>
  <li>Client: Giao tiếp với replicas để nhận log (ví dụ: wallet).
Các wallet không chạy giao thức SMR và cũng không giao tiếp với nhau. Nó hỏi các replicas về các log và chọn kết quả được nhiều replicas gửi về nhất.</li>
</ul>

<h3 id="bảo-mật-cho-smr">Bảo mật cho SMR</h3>
<p>Gọi A ≼ B khi A là tiền tố của B. Ví dụ: A = Tx1Tx2Tx3, B = Tx1Tx2Tx3Tx5Tx6 thì A là tiền tố của B.<br />
Gọi LOG(i, t) là log đưa ra bởi client i ở thời điểm t. Một giao thức SMR là an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  LOG(i, t) ≼ LOG(j, s) hoặc LOG(j, s) ≼ LOG(i, t) hoặc cả 2. =&gt; không thể xảy ra Double Spent</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ LOG(i, s).</li>
</ul>

<h2 id="giao-thức-blockchain">Giao thức Blockchain</h2>
<p>Các Txs được đóng thành các block để tăng thông lượng. Gọi CH(i, t) là chuỗi được accept bởi client i tại thời gian t. Giao thức blockchain đảm bảo an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  CH(i, t) ≼ CH(j, s) hoặc CH(j, s) ≼ CH(i, t) hoặc cả 2</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ CH(i, s).</li>
</ul>

<p>Mong muốn giao thức phải đảm bảo an toàn dưới môi trường bán đồng bộ. Theo DLS(1988), nếu f ≥ n/3 thì giao thức SMR không thể đảm bảo an toàn. Bây giờ với f &lt; n/3, ta sẽ chứng minh là giao thức này an toàn.</p>

<h2 id="chứng-minh">Chứng minh</h2>
<p>Thời gian chia thành các epoch, mỗi epoch là 2Δ giây. Có n replicas cố định, mỗi epoch e được chỉ định 1 leader Le bởi hàm Hash.</p>
<h3 id="baby-streamlet">Baby streamlet</h3>
<p><strong>Đề xuất khối: </strong> Ở đầu mỗi epoch, Le xác định chuỗi dài nhất nó từng thấy cho đến nay và sẽ đề xuất 1 khối liền sau chuỗi đó. <bn>
<strong>Finalization: </strong> 1 replica finalizes block (và tiền tố của nó) ở đầu chuỗi. Nếu có nhiều block như thế, chọn block có epoch nhỏ nhất.<br />
Tuy nhiên, có một nhược điểm là nếu Leader là adversary và network chưa đồng bộ, thì Adversary có thể gửi thông báo các Block cho 1 user bất kì, nhưng thông báo chưa tới các user còn lại cho tới sau GST. 
/// hình minh hoạ</bn></p>

<h3 id="teen-streamlet">Teen streamlet</h3>
<p>Votes: 1 vote trên block bởi replica là chữ kí của nó trên block. <br />
Notarization: 1 block được xem là Notarized dưới góc nhìn của replica nếu block đó có hơn 2n/3 chữ kí từ các replica khác.<br />
<strong>Đề xuất khối: </strong> Đầu mõi epoch e, Le xác định chuỗi Notarized dài nhất và đề xuất khối sau chuỗi Notarized này.<br />
<strong> Vote: </strong> ∆ giây ở epoch e,mỗi replica vote cho đề xuất hợp lệ đầu tiên dưới góc nhìn của Le (mở rộng chuỗi dài nhất theo góc nhìn của nó).<br />
<strong>Finalization: </strong>  1 replica finalize 1 block và tiền tố của nó sau khi thấy khối được notarized.</p>

<p>Ví dụ: /// hình ảnh <br />
Chứng minh: với f &lt; n/3, với mỗi epoch e, chỉ có tối đa 1 notarized block với epoch là e trong góc nhìn của bất kì replica trung thực nào. <br />
Giả sử 2 khối cùng epoch e là B và B’. Vì f &lt; n/3 nên tồn tại replica vote cho cả B, B’. Mà số vote của B và B’ lớn hơn 2/3 =&gt; số replica vote cho cả 2 là &gt; n/3. Đây là vô lý. Vậy khi network chưa đồng bộ, giao thức này đảm bảo an toàn.<br />
Với các block có epoch khác nhau, có thể cùng ở chung 1 độ cao. Gọi 2 block đó là B1 và B2. Ban đầu, ở B, adversarial đề xuất B1 cho 66 replica trung thực, nên B1 chưa được notarized (vì có 66 vote). Tiếp theo, B2 được đề xuất bởi 1 replica trung thực, và được notarized nhưng trong đó có 1 adversarial vote cho B1, nên B1 cũng được notarized. Từ đó dẫn đến vi phạm safety.</p>

<h3 id="streamlet">Streamlet</h3>
<p><strong>Finalization: </strong> Khi thấy 3 khối kề nhau trong chuỗi được notarized với epoch liên tiếp, thì client sẽ finalize block thứ 2 trong 3 block trên và tẩt cả tiền tố của nó.</p>

<p>Độ phức tạp giao tiếp là O(N^3) message cho mỗi block, vì mỗn honest replica chuyển tiếp các votes nó nhận từ các replica khác cho tất cả các replica.
Chứng minh tính an toàn:<br />
<strong> Safety: </strong> Giả sử có 2 block đang trong tình trạng confict ở epoch e và e’. Nếu: <br /></p>
<ul>
  <li>e = e’: không thể (đã chứng minh ở Teen Streamlet).<br /></li>
  <li>e &lt; e’: suy ra e+1 &lt; e’. Vì B3 được notarized nên có ít nhất S &gt; n/3 replica trung thực vote cho B3 tại e+1. Vậy S sẽ thấy B2 được notarized ở đầu epoch e+1, do đó, S sẽ không vote cho B’ vì B’ không mở rộng từ chuõi dài nhất. Mà S &gt; n/3 nên B’ không được notarized. <br /></li>
  <li>e &gt; e’: suy ra e-1 &gt; e’. Nếu B’ được notarized, có S &gt; n/3 replica trung thực vote cho nó tại epoch e’. Vậy S sẽ thấy B” được notarized ở đầu epoch e”, do đó S sẽ không vote cho B1. Tương tự, B1 không được notarized. Điều này trái với giả thiết.<br />
Hình Minh Hoạ: <br />
Vậy, Streamlet đảm bảo safety<br /></li>
</ul>

<p><strong> Liveness: </strong> Giả sử có 4 slot liên tiếp: e, e + 1, e + 2, e + 3 với leader trung thực sau GST. Ở cuối các slot này, client sẽ finalize block được đề xuất bởi các replica trung thực. Trong đó:</p>
<ul>
  <li>1 slot để undo các hành động của adversary. <br /></li>
  <li>3 slot để finalize block. <br />
Ngoài ra, đảm bảo không có 2 block liên tiếp nhau mà chưa được notarized.</li>
</ul>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.]]></summary></entry><entry><title type="html">Cơ chế Bitcoin</title><link href="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin" rel="alternate" type="text/html" title="Cơ chế Bitcoin" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/co-che-bitcoin</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/co-che-Bitcoin"><![CDATA[<p>Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.</p>

<h3 id="thời-gian-đóng-các-khối">Thời gian đóng các khối</h3>
<p>Cứ sau mỗi 10 phút, mỗi miner sẽ tạo 1 block tiềm năng từ các Tx trong mempool của nó. Các Tx được ưu tiên theo phí giao dịch. 1 miner được chọn (sau khi giải được bài toán PoW) sẽ phân tán block đó cho toàn mạng và mọi miner khác sẽ xem được block, sau đó block được đưa vào chuỗi. Phần thưởng là 6.25 BTC. Phần thưởng này được gửi cho miner thông qua coinbase Tx (là Tx đầu tiên trong block chứa địa chỉ ví của miner do ,miner thêm vào).</p>

<h2 id="cấu-trúc-của-một-transaction">Cấu trúc của một Transaction</h2>
<p>Transaction trong Bitcoin chia làm 2 phần chính là Input và Output.
Input gồm 3 phần chính:</p>
<ul>
  <li>Previous Tx ID: ID của Tx trước đó mà tạo ra Bitcoin ở Output để sử dụng trong giao dịch hiện tại.</li>
  <li>Previous Tx index: Vì một Tx có thể có nhiều Output nên index này được sử dụng để xác định output trong Tx trước đó. Danh sách các output được xem như 1 tập hợp bên trong Tx.</li>
  <li>ScriptSig: Script Signature. Nó mã hoá Public key và chữ kí của người sở hữu Bitcoin ở hiện tại.</li>
</ul>

<p>Output: là những bitcoin mới được khoá với Hash của Public Key của người nhận. Bitcoin sử dụng mô hình UTXO là Bitcoin chỉ có thể sử dụng 1 lần, sau mỗi giao dịch thì bitcoin cũ sẽ bị loại bỏ và một lượng bitcoin mới được tạo ra. Output gồm 2 phần chính:</p>
<ul>
  <li>Value: Số lượng bitcoin mà được gửi cho người nhận. (Min: 1 satoshi = 10^-8 BTC)</li>
  <li>ScriptPubKey: Là một dãy các chỉ dẫn (Như 1 hàm) mà nhận ScriptSig là Input và trả về True nếu người sở hữu hợp lệ mở khoá Bitcoin này. Ngược lại, nó trả về false.</li>
</ul>

<p>Một giao dịch có thể có nhiều Input và Output. Các input có thể từ nhiều user (gọi là MultiSig Tx), các output có thể đến nhiều user.</p>

<p>Ngoài ra, trong Tx còn có 2 phần khác là segwit và locktime.</p>

<h3 id="miner-xác-minh-một-tx-như-thế-nào">Miner xác minh một Tx như thế nào</h3>
<p>Một Tx thoả mãn khi:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPK trả về True. Tức là với điều kiện nào thì UTXO có thể được tiêu.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>TxID</td>
          <td>index: hiện ở trong tập các UTXO</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>tổng Input values &gt; tổng Output values: Không thể tiêu nhiều hơn số tiền đang có.
Sau khi 1 Tx được post lên, miners sẽ xoá UTXO tương ứng của nó trong tập.</li>
</ul>

<h2 id="các-loại-tx">Các loại Tx</h2>
<h3 id="pay-to-public-key-hash-p2pkh">Pay to public key hash (P2PKH)</h3>
<p>Trước tiên, mọi người cần hiểu về một số op codes hoạt động trong Bitcoin Script ở <a href="https://wiki.bitcoinsv.io/index.php/Opcodes_used_in_Bitcoin_Script">đây</a>. 
Giả sử Alice muốn gửi cho Bob 5BTC. Alice và Bob sẽ làm các bước sau:</p>
<ul>
  <li>Bob tạo sig : gọi Gen():  (pkB, skB)</li>
  <li>Bob tính địa chỉ bitcoin của mình bằng: addrB = H(pkB)</li>
  <li>Bob gửi addrB cho Alice</li>
  <li>
    <p>Alice tạo giao dịch Tx-fund với Output[0] là: UTXO[0]: 5, ScriptPkB với ScriptPkB là:</p>

    <p>DUP  HASH256  «addrB»  EQVERIFY  CHECKSIG</p>
  </li>
</ul>

<p>còn ở Input, Alice có ScriptSig để xác thực Bitcoin của Alice có chứa chữ ký của Alice lên Tx này, khiến cho không ai có quyền thay đổi ScriptPkB.</p>

<p>Sau đó, Bob muốn sử dụng UTXO[0] thì sẽ tạo 1 Tx-spend với ScriptSigB trong input, bao gồm «sig» và «pkB» với Sig = Sig(skB, Tx) (Tx này là Tx-spend nhưng không chứa các ScriptSig).</p>

<p>Miner có thể xác thực ScriptSigB|ScriptPkB = true và cho phép B sử dụng số tiền.
Một số lưu ý như:</p>
<ul>
  <li>Người nhận (Bob) không thể tiết lộ PkB cho đến khi UTXO được dùng (vì bảo mật).</li>
  <li>Vì tránh việc tấn công bằng cách thay đổi Sig, Sig được chuyển vào phần witness và TxID được tính bằng:               TxID = H(Tx không chứa witness).</li>
</ul>

<h3 id="pay-to-script-hash-p2sh">Pay to script hash (P2SH)</h3>
<p>Người nhận (Bob) thay vì tạo address là H(pkB) thì tạo 1 redeem script, sau đó gán địa chỉ để người gửi (Alice) chuyển qua thành H(redeem script).
Ví dụ:</p>
<ul>
  <li>ScriptPK ở UTXO: HASH160   «H(redeem script)»  EQUAL</li>
  <li>ScriptSig để tiêu: {sig1 , sig2, …, sign, redeem script}
Từ đây, người gửi (Alice) có thể thêm các điều kiện phức tạp để xác định khi nào người nhận (Bob) có thể tiêu.</li>
</ul>

<p>Reedem Script: là các điều kiện thoả mãn để có thể sử dụng UTXO như: số chữ kí tối thiểu, thời gian,…</p>

<p>Các miner xác minh bằng cách:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>ScriptSig</td>
          <td>ScriptPk = true: Bob gửi đúng script.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ScriptSig = true: script là thoả mãn (tức là sẽ tồn tại điều kiện để Bob có thể dùng UTXO).</li>
</ul>

<h4 id="ví-dụ-multisig">Ví dụ: MultiSig</h4>
<p>Muốn dùng UTXO thì cần t/n chữ kí. Ví dụ với 2 / 3 chữ kí. Redeem Script và ScriptSig được viết như sau:</p>
<ul>
  <li>Redeem Script: 	2, PK1, PK2, PK3, 3, CHECKMULTISIG</li>
  <li>ScriptSig: 0, sig1, sig3, redeem script</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Ngoài những dạng Tx ở trên, sẽ có nhiều dạng Tx khác được sử dụng ở trong nhiều trường hợp cụ thể.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Với mỗi Miner, họ sẽ thông thường được connect với 8 người khác. Khi một Tx được gửi đến, Miners sẽ thông báo là nhận được Tx trên mạng P2P. Mọi miners sẽ xác thực rằng Tx đã nhận và lưu vào trong Mempool. Mempool là nơi chứa những Tx đang chờ được xử lý. Các nodes này chia sẻ dữ liệu mempool với nhau bằng cách chuyển tiếp các Tx đã kí với nhau cho đến khi nó được toàn bộ mạng lưới.]]></summary></entry><entry><title type="html">Cấu tạo block và PoW</title><link href="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow" rel="alternate" type="text/html" title="Cấu tạo block và PoW" /><published>2023-07-20T00:00:00+07:00</published><updated>2023-07-20T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/20/cau-tao-block-va-pow"><![CDATA[<p>Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).</p>

<h2 id="cấu-tạo-block-trong-bitcoin">Cấu tạo block trong bitcoin</h2>
<p>Các block chứa các dữ liệu về Tx được lưu vào trong sổ cái công khai. Block có các header, nơi chứa các siêu dữ liệu giúp quản lý block đó. Kích thước blockheader là 80 bytes, trong khi các giao dịch trung bình khoảng 250 bytes và mỗi khối trung bình chứa được 500 Tx.</p>

<p>Ở trong blockheader chứa các dữ liệu liên quan đến các block đó. Đầu tiên, là giá trị hash của block liền trước nó(32 bytes), giúp đảm bảo liên kết trong chuỗi. Tiếp theo là Version (4 bytes) là phiên bản của block hiện tại. Merkle Root cũng được lưu ở đây (32 bytes), là giá trị hash của của gốc cây Merkle của các Tx. 4 bytes Timestamp là chỉ thời gian block được tạo, được tính bằng số giây từ 01/01/1970. Tiếp theo là Hash Target/ Difficult Target (4 bytes) là giá trị hash mục tiêu của PoW cho block này. Cuối cùng là số nonce (4 bytes), là giá trị mà các miner tìm để giải bài toán PoW.</p>

<h2 id="proof-of-work">Proof of Work</h2>
<p>PoW là một phần dữ liệu khó tạo (là đáp án cho một bài toán) hoặc rất tốn kém, mất thời gian để tạo nhưng chỉ tốn 1 thời gian rất ngắn (đpt O(1)) để có thể kiểm tra xem đáp án đó có đúng không. Quy trình tạo dữ liệu này là ngẫu nhiên với xác suất thấp, cần thử sau rất nhiều lần trước khi tạo ra PoW hợp lệ.</p>

<p>PoW là cách để các nodes cùng đồng thuận về tình trạng của block, tránh việc <a href="https://academy.binance.com/vi/articles/double-spending-explained">chi tiêu khép</a>, từ đó cho phép cập nhập blockchain theo các quy tắc của hệ thống.</p>

<h3 id="ví-dụ-với-bitcoin">Ví dụ với Bitcoin:</h3>
<p>Trong quá trình tạo khối, các miner sẽ phải giải được bài toán tìm số nonce để đưa vào blockheader và khiến block hợp lệ. Block hợp lệ là block có hash nhỏ hơn target value hiện tại.
Hash của block là lấy (Tổng của: Merkle Root, Version, Timestamp, Target, PreviousHash, Nonce) hash 2 lần,nếu Hash này nhỏ hơn hoặc bằng Target, tức là block này hợp lệ. Block này sau đó sẽ được đưa vào chuỗi sau khi các nodes khác verify rằng nonce này là hợp lệ (với độ phức tạp O(1)). Ngược lại, các miner sẽ phải tìm số Nonce khác.</p>

<p>Độ khó (Target Hash) sẽ được thay đổi sau 2016 block (2 tuần) được sinh ra. Nếu thời gian sinh 2016 block này nhanh hơn, Target Hash sẽ được điều chỉnh xuống, ngược lại sẽ tăng lên. Sau khi cập nhập, các nodes cùng chia sẻ một Target.</p>

<h3 id="incentive">Incentive</h3>
<p>Sau khi tạo được block, miner sẽ nhận phần thưởng và Tx phí thông qua coinbase mà họ đưa vào block. <br />
Coinbase là giao dịch đầu tiên trong block, được tạo bởi miner nhằm mục đích nhận phần thưởng và Tx phí. Do đó, coinbase không có input, chỉ có output là địa chỉ ví của miner. Bitcoin nhận được từ coinbase không thể được sử dụng cho đến khi đạt 100 xác nhận trong blockchain.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>PoW là một cơ chế đồng thuận được sử dụng ở nhiều blockchain khác nhau, tuy nhiên nó cũng mang lại nhiều bất lợi. Những cơ chế đồng thuận khác sẽ được viết ở những bài sau.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Trong bài viết ngày hôm nay, mình sẽ nói kĩ hơn về cấu tạo của block trong blockchain và cơ chế đồng thuận PoW (Proof of Work).]]></summary></entry></feed>