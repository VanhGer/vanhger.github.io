<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-18T15:41:08+07:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Mở rộng Blockchain (Phần 1)</title><link href="http://localhost:4000/blog/2023/08/18/scaling-the-blockchain-p1" rel="alternate" type="text/html" title="Mở rộng Blockchain (Phần 1)" /><published>2023-08-18T00:00:00+07:00</published><updated>2023-08-18T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/08/18/scaling-the-blockchain-p1</id><content type="html" xml:base="http://localhost:4000/blog/2023/08/18/scaling-the-blockchain-p1"><![CDATA[<p>Với Bitcoin, tốc độ thực hiện giao dịch chỉ có khoảng 7 Tx / sec, còn với Ethereum, con số này là 15. Trong khi đó, với VISA là 2000, Paypal là 200. Vậy để các loại Blockchain này được sử dụng nhiều trên thế giới, cần phải có những giải pháp để tăng tốc độ các giao dịch. Trong bài viết này, mình sẽ giới thiệu đến một cách là sử dụng Payment Channel, hạn chế tương tác với chuỗi càng ít càng tốt, giúp tăng tốc độ.</p>

<h2 id="payment-channel-ý-tưởng-cơ-bản">Payment Channel: Ý tưởng cơ bản</h2>
<p>A và B đang muốn giao dịch với nhau. A gửi cho B 5 lần, mỗi lần là 0.01 BTC, là 5 Txs. Thay vì làm như thế, có thể làm như sau: A gửi cho B 1BTC. Sau 1 khoảng thời gian (ví dụ 1 tháng), B sẽ trả lại số BTC dư mà chưa dùng. Vậy số giao dịch chỉ giới hạn đến 2.</p>

<h2 id="unidirectional-payment-channel-kênh-thanh-toán-1-chiều">Unidirectional Payment Channel: Kênh thanh toán 1 chiều</h2>
<p>Ta có: UTXO A: 1BTC.</p>
<ul>
  <li>Tx1: 0.99 cho A/ 0.01 cho B từ UTXO A.</li>
  <li>Tx2: 0.98 cho A/ 0.02 cho B</li>
  <li>….</li>
  <li>Tx5: 0.95 cho A/ 0.05 cho B</li>
</ul>

<p>Xong xuôi, B post Tx5 lên Blockchain. Nhưng có vấn đề xảy ra là nếu A sử dụng UTXO trước khi B post lên thì Tx5 mà B post lên sẽ không hợp lệ. Do đó, cần sử dụng 1 địa chỉ chung UTXO AB có dạng Multisig 2-2. Điều này sẽ ngăn chặn việc A dùng UTXO vì chưa có chữ kí của B.</p>

<p>Nhưng nếu B không post Tx5 lên chuỗi thì sao? Liệu A có lấy lại được 0.95 BTC. Để giải quyết vấn đề này, cần sử dụng một time-locked Tx, đảm bảo sau một khoảng thời gian, nếu B không post Tx5 lên, thì A sẽ lấy lại được 1BTC (B phải gửi cho A). Ngoài ra, Tx này phải được kí trước khi đưa BTC vào trong AB.</p>

<p>Minh hoạ:</p>

<p>Sau khi trả hoặc lấy lại tiền, kênh sẽ đóng.</p>

<h2 id="bidirectional-payment-channel-kênh-thanh-toán-đa-chiều">Bidirectional Payment Channel: Kênh thanh toán đa chiều</h2>
<p>Không sử dụng 2 kênh thanh toán 1 chiều thay thế. Thay vào đó, ta sẽ sử dụng contract.</p>

<h3 id="trên-ethereum">Trên Ethereum</h3>
<p>A và B sẽ tạo một contract chung, mỗi người đóng góp 0.5 ETH. Lúc này, trạng thái của contract sẽ là: <br />
A: 0.5 ETH      B: 0.5 ETH      Nonce: 0. <br />
Off chain: B gửi 0.1 ETH cho A bằng cách cả 2 ký vào state mới: <br />
A: 0.6,  B: 0.4,  Nonce: 1, A sig,  B sig   <br />
Ở trên chuỗi, contract vẫn không đổi. Giả sử, offchain, A và B đã gửi đi gửi lại nhiều giao dịch:<br />
A: 0.3,  B: 0.7,  Nonce: 7, A sig,  B sig <br /></p>

<p>Lúc này, A muốn kết thúc kênh, sẽ gửi số dư cuối cùng và các chữ ký cho contract. Lúc này sẽ bắt đầu Challenge Period (ví dụ 3 ngày). <br />
Onchain: A: 0.3,    B: 0.7,     Nonce: 7. <br /></p>
<ul>
  <li>Nếu trong 3 ngày, B không làm gì thì số tiền và trạng thái của contract sẽ theo những gì A gửi lên.</li>
  <li>Ngược lại, nếu B gửi lên 1 state với số Nonce lớn hơn (ví dụ = 9), thì contract sẽ theo state của B.</li>
</ul>

<p>Vấn đề được đưa ra là việc A và B phải quan sát thường xuyên xem đối phương có gửi state cũ lên không để có thể kịp thời ngăn chặn. Điều này được giải quyết bằng sự trợ giúp của WatchTower.</p>

<p>Tóm lại, việc giao dịch sẽ chỉ tốn 2 lần onchain:</p>
<ul>
  <li>Tạo channel</li>
  <li>Đóng channel và gửi tiền.</li>
</ul>

<h3 id="trên-bitcoin">Trên Bitcoin</h3>
<p>Vì trên UTXO không có trạng thái, nên sẽ khó khăn hơn để tạo 1 kênh thanh toán 2 chiều. Giải pháp được đưa ra là khi update kênh theo A, thì A sẽ nhận được Tx mà làm trạng thái cũ của B mất hiệu lực.</p>

<h4 id="utxo">UTXO</h4>
<p>Ta sẽ tạo UTXO mà có thể dùng theo 1 trong 2 cách (sử dụng IF trong Opcode):</p>
<ul>
  <li>Relative time-lock: UTXO chứa số t. 1 Tx được kí hợp lệ có thể sử dụng UTXO này sau t blocks (hoặc nhiều hơn) sau khi nó được tạo ra.</li>
  <li>Hash lock: UTXO chứa một số X. Một Tx được kí hợp lệ có thể sử dụng UTXO này nếu có số x mà: SHA256(x) = X.
(x được gọi là hash preimage của X).</li>
</ul>

<h4 id="ví-dụ">Ví dụ:</h4>
<p>Giả sử A và B đưa BTC vào trong 2-2 Multisig UTXO AB, với A là 7BTC, B là 3BTC. <br /></p>
<ul>
  <li>A tạo số ngẫu nhiên x, và X = SHA256(x).</li>
  <li>B tạo số ngẫu nhiên y, và Y = SHA256(y).</li>
  <li>Sau đó, A đưa X cho B và ngược lại.</li>
  <li>A tạo Tx1 với input là UTXO AB, output là: <br />
  1: pay 7 -&gt; A,  <br />
  2: 3 -&gt; B (7 ngày timelock) hoặc 3 -&gt; A (với điều kiện đưa ra số y mà Y = SHA256(y)).</li>
  <li>B tạo Tx2 với input là UTXO AB, output là: <br />
  1: pay 3 -&gt; B, <br />
  2: 7 -&gt; A (7 ngày timelock) hoặc 7 -&gt; B (với điều kiện đưa ra số x mà X = SHA256(x)).</li>
  <li>A có thể post Tx2, đợi 7 ngày và lấy 7 BTC về.</li>
  <li>Giờ nếu A gửi 1BTC cho B offchain. A tạo x’ và X’ = SHA256(x’). Sau đó đưa X’ cho B.</li>
  <li>A tạo Tx3 với input là UTXO AB, output là: <br />
  1: pay 6 -&gt; A,  <br />
  2: 4 -&gt; B (7 ngày timelock) hoặc 4 -&gt; A (với điều kiện đưa ra số y mà Y = SHA256(y)).</li>
  <li>B tạo Tx4 với input là UTXO AB, output là: <br />
  1: pay 4 -&gt; B, <br />
  2: 6 -&gt; A (7 ngày timelock) hoặc 6 -&gt; B (với điều kiện đưa ra số x’ mà X’ = SHA256(x’)).</li>
  <li>Lúc này, A có thể post Tx3 và đợi 7 ngày. Nhưng nếu A post stale state là Tx2, B sẽ sử dụng x để lấy hết BTC. Do đó, A không thể gian lận và post lên trạng thái cũ.</li>
</ul>

<h2 id="multihop-payments-thanh-toán-nhiều-lần">Multihop payments: Thanh toán nhiều lần</h2>
<p>A muốn thanh toán cho C qua trung gian không tin cậy là B (Vì A, C có channel với B).</p>

<h3 id="the-lightning-network">The lightning network</h3>
<p>Nhiều open payment channel 2 chiều. Khi A muốn tạo kênh với B thì chỉ cần tìm tuyến đường qua đồ thị với đỉnh là các trung gian.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Đây là cách tiếp cận đầu tiên để tăng lượng Tx trong 1sec. Ở bài viết sau, mình sẽ giới thiệu các khác giúp giải quyết vấnd dề này.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Với Bitcoin, tốc độ thực hiện giao dịch chỉ có khoảng 7 Tx / sec, còn với Ethereum, con số này là 15. Trong khi đó, với VISA là 2000, Paypal là 200. Vậy để các loại Blockchain này được sử dụng nhiều trên thế giới, cần phải có những giải pháp để tăng tốc độ các giao dịch. Trong bài viết này, mình sẽ giới thiệu đến một cách là sử dụng Payment Channel, hạn chế tương tác với chuỗi càng ít càng tốt, giúp tăng tốc độ.]]></summary></entry><entry><title type="html">Hệ thống vay DeFi</title><link href="http://localhost:4000/blog/2023/08/17/defi-lending-system" rel="alternate" type="text/html" title="Hệ thống vay DeFi" /><published>2023-08-17T00:00:00+07:00</published><updated>2023-08-17T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/08/17/defi-lending-system</id><content type="html" xml:base="http://localhost:4000/blog/2023/08/17/defi-lending-system"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu về hệ thống vay trong môi trường phi tập trung. Nhưng trước hết, ta sẽ đi tìm hiểu việc vay trong hệ thống tập trung sẽ như thế nào và chứa những rủi ro gì.</p>

<h2 id="vay-trong-hệ-thống-tập-trung">Vay trong hệ thống tập trung</h2>
<p>Vì sao cần vay? Có các lý do chính như sau:</p>
<ul>
  <li>Ví dụ, Bob cần vay ETH để mua một NFT trong game nhưng anh ấy không muốn bán tài sản của mình đi.</li>
  <li>Là chiến lược đầu tư, khi thế chấp ETH để nhận UNI, chờ tỉ giá UNI/ETH giảm, thì số UNI bỏ ra để mua 1ETH trả khoản vay sẽ ít hơn, từ đó nhận được UNI lãi.</li>
</ul>

<p>Trong hệ thống tập trung, người cho vay gửi tiền vào một Tổ chức tài chính tập trung. Người vay sẽ thế chấp 1 loại tài sản nào đó và sẽ được vay. Sau đó, người vay sẽ phải trả tiền lãi cho đến khi trả xong phần đã vay. Người cho vay sẽ được nhận 1 phần lãi đó. <br /> Tuy nhiên, nếu người vay không trả được khoản vay, Tổ chức tài chính tập trung sẽ mua lại tài sản thế chấp, và trả lại cho người vay phần còn thừa. <br /> Nếu giá trị tài sản thế chấp bị thay đổi và ít hơn tài sản vay, việc thanh lý tài sản thế chấp sẽ xảy ra.</p>

<p>Tuy nhiên, với hệ thống tập trung, có các vấn đề được thấy rõ như sau:</p>
<ul>
  <li>User cần tin tưởng Tổ chức, nhưng nếu bị hack hoặc bị xâm nhập trái phép, khả năng mất tiền rất cao.</li>
  <li>Tổ chức điều chỉnh tỉ lệ lãi,..</li>
  <li>Người cho vay sẽ nhận ít tiền lãi hơn, vì phải chia 1 phần cho tổ chức.</li>
</ul>

<p>Do đó, việc tạo ra hệ thống vay phi tập trung không cần bên thứ 3 và áp dụng tính lập trình là mục tiêu được người dùng hướng đến.</p>

<h2 id="các-thuật-ngữ">Các thuật ngữ</h2>
<p><strong> Collateral </strong>: Tài sản thế chấp. Vai trò là đặt cọc để vay.</p>

<p><strong> Over-collateralization </strong>: Thế chấp vượt mức. Người vay phải đảm bảo giá trị thế chấp &gt; giá trị vay.</p>

<p><strong> Under-collateralization </strong>: Thế chấp dưới mức. Xảy ra khi giá trị thế chấp &lt; giá trị vay.</p>

<p><strong> Collateral Factor </strong>: Giá trị lớn nhất có thể vay, tính theo giá trị thế chấp. Ví dụ CF = 0.6, thế chấp có giá trị là 1000 DAI thì giá trị vay lớn nhất có thể là 0.6 * 1000 = 600 DAI.<br />
Với tài sản có độ biến động cao, CF thường thấp, ngược lại thì CF cao. Ví dụ: ETH, DAI:  83%, UNI: 75%, MKR:  73%</p>

<p><strong> Thanh lý </strong> : Nếu số tiền vay + lãi (gọi là nợ - Debt) &gt; CF * Collateral (1) <br />
=&gt; Tài sản thế chấp sẽ được thanh lý đến khi (1) không còn xảy ra.  Tỉ lệ thanh lý giúp người cho vay có thời gian thanh lý trước khi gặp rủi ro.</p>

<p><strong> Health </strong> : Health của 1 món nợ được tính bằng công thức sau: <br /> <img src="https://latex.codecogs.com/svg.image?%20BorrowCapacity=%5Csum_%7Bi%7D%5E%7B%7Dvalue(collateral_%7Bi%7D)*CF_%7Bi%7D" alt="Alt text" /> <br />
<img src="https://latex.codecogs.com/svg.image?health=%5Cfrac%7BBorowCapacity%7D%7Btotal%20Debt%7D" alt="" /> <br /></p>

<p>Nếu health &lt; 1: Thanh lý sẽ được kích hoạt đến khi health &gt;= 1.</p>

<p><strong> Liquidity </strong>: Thanh khoản. Là loại tài sản mà việc mua bán trên thị trường không thay đổi giá trị thị trường của nó. Nó cũng có khả năng chuyển thành tiền mặt.</p>

<h2 id="defi-lending">DeFi Lending</h2>
<h3 id="ý-tưởng-với-orderbook-dapp">Ý tưởng với OrderBook Dapp</h3>
<p>Lưu trữ các giao dịch trên một OrderBook. Người vay tạo giao dịch vay và chờ người cho vay fill.
Bất lợi:</p>
<ul>
  <li>Nhiều Txs, dẫn đến tính toán phức tạp</li>
  <li>Rủi ro: Không trả được nợ,..</li>
  <li>Rút tiền phức tạp</li>
</ul>

<h3 id="liquidity-pool">Liquidity Pool</h3>
<p>Over-collateralized lending:  Compound and Aave
Các LP (Liquidity Provider) cung cấp tài sản vào pool, và nhận những token tương ứng với tài sản mà họ đã cung cấp. Số lượng các token dựa vào Exchange Rate hiện tại. Exchange Rate sẽ được tính lại sau mỗi block.</p>

<p>Với người vay, họ gửi tài sản vào Pool và nhận cTokens. Sau đó khi muốn vay (ETH), thì token của họ sẽ bị khoá như là Collateral, sau đó Compound sẽ gửi ETH cho họ. <br />
Tiền lãi tích luỹ khi vay của người vay sẽ làm tăng Exchange Rate ETH/token, từ đó giúp những người cho vay (giữ các token) được lợi ích khi token sẽ tăng giá.</p>

<h3 id="the-exchange-rate">The Exchange Rate</h3>
<p>Giả sử với thị trường ETH:</p>
<ul>
  <li>Supplying ETH: thêm vào UnderlyingBalance</li>
  <li>Borrowing ETH: thêm vào totalBorrowBalance</li>
  <li>Lãi phải trả: thêm lần lượt vào totalBorrowBalance<br /></li>
</ul>

<p><img src="https://latex.codecogs.com/svg.image?ExchangeRate_%7BETH/token%7D=%5Cfrac%7BUnderlyingBalance&plus;totalBorrowBalance-reserve%7D%7BcTokenSupply%7D" alt="" /></p>

<p>Do đó, nếu tổng lượng vay càng nhiều, thì Exchange Rate sẽ càng tăng. Ngược lại nếu lượng UnderlyingBalance tăng thì lượng cTokenSupply tương ứng cũng sẽ tăng, từ đó dẫn đến ExchangeRate giảm.</p>

<h3 id="interest-rate-lãi-xuất">Interest Rate: Lãi xuất</h3>
<p>Lãi xuất được cập nhập một cách liên tục. Xác định bởi nhu cầu về tài sản với quy mô thị trường.<br />
Tỉ lệ sử dụng: <br />
<img src="https://latex.codecogs.com/svg.image?U_%7BETH%7D=%5Cfrac%7BtotalBorrowBalance%7D%7BavailableBalance&plus;totalBorrowBalance%7D" alt="" /> <br />
Tỉ lệ này thuộc khoảng [0,1]. <br />
Tỉ lệ lãi: interestRate = BaseRate + U(ETH) x slope(ETH).</p>

<h3 id="thanh-lý">Thanh lý</h3>
<p>Nếu health &lt; 1, thì ai cũng có thể gọi hàm: <br />
liquidate(borrower,   CollateralAsset,   BorrowAsset,  uint amount) <br />
Trong đó:</p>
<ul>
  <li>borrower: address của người vay</li>
  <li>CollateralAsset: người thanh lý muốn token từ tài sản này (VD: cDAI)</li>
  <li>BorrowAsset: người thanh lý cung cấp tài sản này (ví dụ ETH) <br /></li>
</ul>

<p>Hàm này chuyển ETH của người thanh lý ra thị trường ETH và cung cấp cho người thanh lý cDAI từ tài sản thế chấp của người dùng. Điều này tương đương với người thanh lý đang trả khoản nợ ETH cho người vay và nhận cDAI của người dùng.</p>

<h2 id="flash-loan">Flash loan</h2>
<p>Là khoản vay nhanh được thực hiện và hoàn trả trong 1 giao dịch. <br />
=&gt; zero risk cho người gửi, và không cần thế chấp.</p>
<h3 id="các-trường-hợp-được-sử-dụng">Các trường hợp được sử dụng</h3>
<h4 id="chênh-lệch-giá">Chênh lệch giá:</h4>
<p>Người dùng Alice thấy chênh lệch giá USDC/DAI trong 2 pool, có thể dùng flash loan để kiếm lời. Ví dụ ở pool A có ExchangeRate là: 1.00, trong khi ở pool B là 1.01 thì Alice có thể flash loan 1 USDC, dùng để đổi được 1.01 DAI từ pool B. Sau đó dùng 1.00 DAI đổi lấy 1 USDC từ pool A, và trả flash loan. Do đó, Alice sẽ lời được 0.01 DAI.</p>

<h4 id="hoán-đổi-tài-sản-thế-chấp">Hoán đổi tài sản thế chấp</h4>
<p>Nhận thấy việc thế chấp bằng ETH có thể bị sụt giá dẫn đến thanh lý, người dùng có thể đổi tài sản thế chấp thành USDC. Quá trình như sau:</p>
<ul>
  <li>Nhận 1000 DAI flash loan</li>
  <li>Trả 1000 DAI để nhận 1 cETH</li>
  <li>Đổi 1 cETH lấy 3000 cUSDC</li>
  <li>Gửi 3000 cUSDC làm thế chấp để Mượn 1000 DAI</li>
  <li>Trả 1000 DAI flash loan</li>
</ul>

<h2 id="một-số-thông-tin-khác">Một số thông tin khác</h2>

<h3 id="dao-decentralized-orgs">DAO: Decentralized orgs</h3>
<p>Là 1 DApp được triển khai onchain tại 1 địa chỉ cụ thể. <br />
Ai cũng có thể gửi tiền vào kho bạc của DAO và gửi đề xuất lên DAO. Đề xuất được thông qua và được các thành viên tham gia vote.
Ví dụ:</p>
<ul>
  <li>PleaseDAO: đầu tư vào NFTs</li>
  <li>Gitcoin: Tài trợ cho các dự án openSource.</li>
</ul>

<h3 id="giao-thức-compound">Giao thức Compound</h3>
<p>Là giao thức trên Ethereum, thiết lập thị trường tiền tệ, là những nhóm tài sản có lãi suất theo thuật toán, dựa và cung và cầu của tài sản đó. Các nhà cung cấp và người vay sẽ tương tác trực tiếp với giao thức, không cần phải thương lượng các điều khoản như kì hạn, lãi suất, hoặc tài sản thế chấp,..</p>

<h3 id="supplying-assets">Supplying Assets</h3>
<p>Tổng hợp nguồn cung từ các user. Khi user cung cấp assets, nó trở thành tài nguyên thay thế được, và mang lại tính thanh khoản cáo hơn khi cho vay trực tiếp. Từ đó người cho vay có thể rút tiền bất cứ lúc nào.</p>

<h3 id="borrowing-assets">Borrowing Assets</h3>
<p>Cho phép người dùng vay dễ dàng, sử dụng cTokens làm thế chấp. Người dùng không cần điều khoản đàm phán, ngày đáo hạn,..</p>

<p>Chi tiết về giao thức Compound, các bạn có thể xem ở <a href="https://compound.finance/documents/Compound.Whitepaper.pdf">đây</a></p>

<h3 id="cross-chain-atomicswap">Cross-chain AtomicSwap</h3>
<h4 id="các-thuật-ngữ-cơ-bản">Các thuật ngữ cơ bản</h4>
<p><strong> HTLC</strong>: hash time-locked contract <br /></p>

<p><strong> Time-lock </strong> Khoá thời gian, khi đúng khoá thì cần 1 khoảng thời gian nhất định để pass, tức là hết thời gian thì mới mở được. <br /></p>

<p><strong> Hash lock</strong> Yêu cầu key đúng + secret code. Sau khi nhập code thì sẽ hiển thị lên cho mọi người.</p>

<h4 id="kịch-bản">Kịch bản</h4>
<p>Alice muốn Bitcoin, Bob muốn BCash. A và B quyết định đổi cho nhau. Các bước như sau:</p>
<ul>
  <li>Alice tạo 2 Hashlock, yêu cầu cùng 1 SecretCode. Nhưng key thì 1 cái là key của A, 1 cái cần key của B.</li>
  <li>Alice đặt HashlockA và HashlockB vào lần lượt mailBoxA và mailBox B.</li>
  <li>Alice đưa BCash vào mailbox B, Bob đưa Bitcoin vào mailbox A.</li>
  <li>Sau đso, Alice đến mailboxA, nhập keyA và secretCode, nhận bitcoin. Đồng thời, sau khi Alice nhập, secretCode hiển thị cho mọi người nên Bob sẽ nhập theo + key vào mailBoxB, nhận được BCash.</li>
</ul>

<p>Trường hợp A không nhập SecreteCode hoặc cố ý chỉnh sai SecretCode ở 2 lock, thì time-lock sẽ được sử dụng:</p>
<ul>
  <li>Độ dài của locktime của A phải lớn hơn của B (1 tuần &gt;&lt; 1 ngày) vì A biết secretCode. Do đó, khi B biết A lừa dối, B có thể quay lại mailBoxA và lấy tiền về ngay lập tức (vì lúc đó A vẫn đang đợi hết timelock để lấy được tiền). Ngược lại nếu locktime của A nhỏ hơn hoặc bằng B, thì A có thể đợi đến khi hết hạn, nhập code và lấy tiền (vì A có key của B lúc tạo lock).</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Ở trên là toàn bộ hiểu biết của mình về hệ thống vay phi tập trung.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu về hệ thống vay trong môi trường phi tập trung. Nhưng trước hết, ta sẽ đi tìm hiểu việc vay trong hệ thống tập trung sẽ như thế nào và chứa những rủi ro gì.]]></summary></entry><entry><title type="html">Sàn giao dịch phi tập trung</title><link href="http://localhost:4000/blog/2023/08/15/dex" rel="alternate" type="text/html" title="Sàn giao dịch phi tập trung" /><published>2023-08-15T00:00:00+07:00</published><updated>2023-08-15T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/08/15/dex</id><content type="html" xml:base="http://localhost:4000/blog/2023/08/15/dex"><![CDATA[<h2 id="khái-niệm">Khái niệm</h2>

<p><strong> Sàn giao dịch phi tập trung </strong> là loại ứng dụng phi tập trung, xây dựng với Smartcontract, cho phép users trao đổi ERC20 token hoặc NFT trực tiếp với các users khác.</p>

<h3 id="lợi-ích">Lợi ích:</h3>
<ul>
  <li>Không giữ tiền: Không có bên thứ 3 giữ tiền trung gian các giao dịch</li>
  <li>Chống kiểm duyệt: Ai gửi Tx đều có thể sử dụng</li>
  <li>Permissionless: có thể hỗ trợ bất kì asset nào.</li>
  <li>Thuận tiện: Không phải gửi tài sản trên chuỗi vào một sàn giao dịch</li>
  <li>Tính lập trình: Thanh khoản có thể xem bởi các smartcontract</li>
  <li>Tính nguyên tử:</li>
</ul>

<p><strong> Orderbook </strong> là sổ lệnh, bao gồm các lệnh bạn và mua tài sản theo từng mức giá nhất định. Cơ chế khớp lệnh này khiến lệnh của người dùng được thực thi khi giá của sổ lệnh khớp với giá người dùng mua hoặc bán.</p>

<h2 id="các-loại-dex">Các loại DEX</h2>
<h3 id="on-chain-orderbook">On-chain orderbook</h3>
<p>Market makers đặt các order lên chuỗi, người dùng sẽ điền các order này trực tiếp trên chuỗi nếu họ muốn giao dịch. Tuy nhiên, cách này sẽ gây tốn gas rất nhiều.</p>

<h3 id="off-chain-orderbook">Off-chain orderbook</h3>
<p>Market makers kí các orders ngoài chuỗi. Người dùng sẽ điền các order này rồi submit nó lên chuỗi. Cách này sẽ không tận dụng khả năng lập trình và thanh khoản sẽ không hiển thị với smartcontract.</p>

<h3 id="dutch-auctions">Dutch auctions</h3>
<p>User đặt các order lên chuỗi, giá sẽ từ từ điều chỉnh để thu hút. Market maker sẽ điền order đó khi họ thích mức giá đó. Vấn đề của cách này là điều chỉnh giá chậm</p>

<h3 id="automated-market-maker">Automated market maker</h3>
<p>Market markers sẽ đưa các tài sản vào trong 1 pool. Người dùng sẽ trade với pool đó mới mức giá được xác định bởi thuật toán.<br />
Lợi ích:</p>
<ul>
  <li>Tiết kiệm gas</li>
  <li>Dễ sử dụng, …</li>
</ul>

<h2 id="cách-automated-market-maker-amm-hoạt-động">Cách Automated market maker (AMM) hoạt động</h2>
<p>Giả sử 1 AMM có 2 loại tài sản, 1 là X (risky, ví dụ: ETH), 2 là Y (stable, ví dụ DAI). AMM lưu trữ x đồng X và y đồng Y. AMM đề nghị mua hoặc bán tài sản X ở một giá trị p nào đó.<br /></p>

<p>Giả sử, ta muốn duy trì tài sản X và Y trong pool với tỉ lệ a/b. Giả sử là 50/50
Vì p là giá trị của X nên ta thấy<br />
                    p.x = y <br />
                    &lt;=&gt; p = y / x. <br />
Khi đó, nếu ai đó bán lượng ETH (X) để lấy DAI (Y) thì x sẽ tăng và y giảm xuống. Dó đó giá trị p sẽ giảm đi.
Điều này tương đương với x, y tỉ lệ nghịch với nhau. <br />
Gọi x * y = k thì k được gọi là hằng số dự trữ.</p>

<p>Hình ảnh: ///</p>

<p>Ví dụ: Nếu pool có 10 ETH, 1000 DAI. Giá của 1 ETH = 100 DAI. <br />
Hằng số dự trữ: k = x * y = 10 * 1000 = 10000.</p>

<p>1) Giả sử user muốn đổi DAI lấy ETH. Muốn đổi 500 DAI + 0.3% phí để đổi lấy ETH.  <br />
Lúc này: y’ = 500 + 1500 = 1500. <br />
=&gt; x’ = 10000 / 1500 = 6.66 ETH. <br />
Lúc đó, user này sẽ nhận: 10 - 6.66 = 3.33 ETH =&gt; Giá p của 1 ETH = 150 DAI (Tăng giá).</p>

<p>2) Giả sử user muốn đổi ETH lấy DAI. ĐỔi 6ETH + 0.3% lấy DAI. <br />
Lúc này: x’ = 10 + 6 = 16 <br />
=&gt; y’ - 10000/ 16 = 625. User nhận 1000 - 625 = 375 DAI. <br />
Giá p 1ETH = 62.5 DAI, giảm 37.5 so với ban đầu.</p>

<h3 id="liquidity-provider">Liquidity Provider</h3>
<p>Là những người cung cấp thanh khoản cho pool, nhận lại được các Liquidity Token, tương đương với thanh khoản mà họ cung cấp. Khi người dùng đổi các tài sản trong pool, phần trăm phí sẽ được trả cho các LP này dựa vào số thanh khoản mà họ cung cấp.</p>

<p>Độ thanh khoản của pool được tính bằng công thức:  L = sqrt(k) = sqrt(x * y).</p>

<h3 id="những-điểm-cần-phát-triển-của-amm">Những điểm cần phát triển của AMM</h3>
<ul>
  <li>Phí gas</li>
  <li>Trượt giá: Biến động giá bởi các giao dịch từ người dùng</li>
  <li>Chênh lệch giá</li>
  <li>Hiệu quả sử dụng vốn</li>
</ul>

<h2 id="concentrated-liquidity">Concentrated Liquidity</h2>
<p>Để tăng hiệu quả sử dụng vốn, các LP có thể gửi thanh khoản ở mức giá trong khoảng cụ thể. Ví dụ như ở hình ảnh trên, là chuyển đường cong xy = k xuống dưới và sang trái. <br />
Lí do là vì giá trị p của thanh khoản sẽ chỉ ở trong 1 khoảng nhất định (Ví dụ DAI chỉ ở trong khoảng từ (0.95 ~ 1.05) USD). Do đó, khi PL cung cấp thanh khoản ở khoảng từ (0, ∞) thì hiệu quả sử dụng vốn của họ sẽ không được cao. Do đó, ở mỗi số sàn giao dịch, việc thanh khoản tập trung trông 1 khoảng hữu hạn là 1 vị trí. Vị trí này cần duy trì đủ dữ trữ để hỗ trợ giao dịch trong phạm vi của nó. Từ đó khiến nó hoạt động như một constant product pool với dự trữ lớn hơn trong khoảng đó. Từ đó việc sử dụng vốn sẽ có hiệu quả hơn.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Về cách các loại sàn hoạt động, mọi người có thể xem ở các whitePaper, ví dụ với <a href="https://uniswap.org/whitepaper.pdf">Uniswap</a> .</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Khái niệm]]></summary></entry><entry><title type="html">Solidity và State Trie</title><link href="http://localhost:4000/blog/2023/07/24/solidity-va-state-trie" rel="alternate" type="text/html" title="Solidity và State Trie" /><published>2023-07-24T00:00:00+07:00</published><updated>2023-07-24T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/24/solidity-va-state-trie</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/24/solidity-va-state-trie"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie</p>

<h2 id="solidity">Solidity</h2>
<p>Solidity là ngôn ngữ lập trình cho Blockchain Ethereum, là ngôn ngữ hướng đối tượng, cấp cao để triển khai các smartcontracts. Smartcontract là chương trình chi phối các hành vi của Account trong Ethereum State. Account contract được tạo ra khi chạy một smartcontract. Mọi người có thể đọc account contract state ở trong storage array, nên không bao giờ được lưu trữ các bí mật trong contract.</p>

<p>Một số dạng biến của Solidity như: uint256, address(byte 32), bool,… Các loại tham chiếu là mảng, struct, string, map,… Khi một giao dịch đi từ A ⇾ B ⇾ C ⇾ D thì tại D, msg.sender là C, nhưng tx.origin là A.</p>

<p>ERC20 là API tiêu chuẩn cho fungible token, cung cấp các chức năng cơ bản để chuyển token hoặc cho phép token được sử dụng bởi bên thứ 3.</p>

<p>Các kiểu lưu trữ:</p>
<ul>
  <li>Stack variables: Rẻ để sử dụng, phù hợp với mọi loại dữ liệu (không qua 32 bytes)</li>
  <li>Calldata: Là 1 mảng byte chỉ đọc, tốn gas</li>
  <li>Memory: 1 byte mảng, rẻ, nhưng chi phí tăng theo cấp số nhân, lưu được dữ liệu &gt; 32 bytes</li>
  <li>Storage: Đắt, mappings và các biến state lưu trong này.</li>
  <li>Event logs: rẻ, không cần truy cập đến contract.</li>
</ul>

<p>Ở trên là một số hiểu biết của mình về solidity, về mặt coding, mọi người nên xem ở <a href="https://docs.soliditylang.org/en/latest/">đây</a>.</p>

<h2 id="state-trie-ethereum-state-trie">State trie (Ethereum state trie)</h2>
<p>Hình ảnh đây là cấu trúc được tạo bởi các loại State trong Ethereum: (ở góc phải dưới hình ảnh)</p>

<p><img src="https://i.stack.imgur.com/afWDt.jpg" width="900" height=" 600" /></p>

<p>Có 3 loại state chính là World state, Transaction, và Transaction Receipt.</p>

<h3 id="world-state-trie">World State Trie</h3>
<p>World State Trie Là mapping giữa địa chỉ và Account State. Nó được update bởi các Tx, và lưu trữ mọi thông tin về accounts và có thể lấy được qua các truy vấn.
Trong World State Trie có Account Storage Trie, nơi các dữ liệu liên kết với account được lưu trữ. Nó chỉ liên quan đến các contract account và mọi dữ liệu được ánh xạ giữa các số nguyên 32 byte.</p>

<p>Account State là các thông tin về một Ethereum account, như balance, nonce, storage Root, codehash,… và là lá của World State Trie.</p>

<h3 id="transaction-trie">Transaction Trie</h3>
<p>Transaction Trie lưu trữ các Tx trong Ethereum. Khi các Tx lưu trữ trong block, nó không thể bị thay đổi. Nó được xây dựng theo cấu trúc Modified Merkel Patricia Trie, và chỉ có node root mới được đưa vào trong block.</p>

<h3 id="transaction-receipt-triereceipt-trie">Transaction Receipt Trie(Receipt Trie)</h3>
<p>Transaction Receipt Trie lưu trữ đầu ra của các Txs. Đầu ra là kết quả của một Tx mà được chạy thành công, bao gồm H(Txs), block number, gas Used, địa chỉ của contract.</p>

<h3 id="ví-dụ-cấu-trúc-của-world-state-một-cách-đơn-giản">Ví dụ cấu trúc của World State (một cách đơn giản)</h3>
<p>Để đơn giản, ta giả sử các node lá của World State Trie chỉ bao gồm địa chỉ là số dư theo cặp Key - Value. 
Các loại thông tin:</p>
<ul>
  <li>Leaf Node: node lá của cây, chứa các trạng thái của 1 tài khoản có địa chỉ là Key</li>
  <li>Branch Node: gồm 16 ô, là các tiền tố của Key.</li>
  <li>Extension Node: node chỉ có 1 child</li>
  <li>Nibble: Là phần chung trong Key, 1 Nibble = 4 bits, lưu trong keyend hoặc shared nibble.</li>
  <li>Prefixes:
    <ul>
      <li>0: extension node có số chẵn Nibble</li>
      <li>1: extension node có số lẻ Niblle</li>
      <li>2: leaf node, có số chẵn Nibble</li>
      <li>3: leaf node, có số lẻ Nibble.</li>
    </ul>
  </li>
</ul>

<p>Minh Hoạ:
World State Trie với 4 cặp Key - Value như sau:</p>
<ul>
  <li>a711355: 45 ETH</li>
  <li>a77d337: 1 WEI</li>
  <li>a7f9365: 1.1 ETH</li>
  <li>a77d397: 0.12 ETH</li>
</ul>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiSYWqaPcJtBlnFR4VAaug.png" /></p>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Ở trên là một số khái niệm sơ bộ về Solidity và cấu trúc của Ethereum, cụ thể về các State Trie.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu về Solidity và World State Trie]]></summary></entry><entry><title type="html">Stablecoins</title><link href="http://localhost:4000/blog/2023/07/24/stable-coins" rel="alternate" type="text/html" title="Stablecoins" /><published>2023-07-24T00:00:00+07:00</published><updated>2023-07-24T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/24/stable-coins</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/24/stable-coins"><![CDATA[<p>Stable coin là 1 loại tiền điện tử được tạo để giao dịch với một giá trị không đổi. Mục đích sinh ra Stablecoin là tích hợp tiền tệ trên thế giới thật vào các ứng dụng trên chuỗi và cho phép những người không thể có USD nắm giữ và giao dịch 1 tài sản tương đương.</p>

<h2 id="custodial-stablecoin-stablecoin-kí-gửi">Custodial Stablecoin: Stablecoin kí gửi</h2>
<p>Custodian giữ kho bạc trong 1 ngân hàng truyền thống, mọi giao dịch đều thông qua nó. Ngoài ra, nó có quyền mạnh mẽ như kiểm duyệt khác hàng rút tiền hoặc xoá số dư người dùng. Điều này sẽ nguy hiểm nếu chẳng may bị hack hoặc nhầm lẫn và không đảm bảo sự phi tập trung. Do đó, cách này không được ưu tiên và sử dụng ở thực tế.</p>

<h2 id="synthetic">Synthetic</h2>
<p>Mục tiêu là xây dựng 1 loại non-custodial stablecoin. Tuy nhiên, có một vấn đề là ETH thường xuyên dao động, không ổn định so với USD.<br />
<strong> Maker DAO: </strong>  xây dựhng một stablecoin từ tài sản không ổn định. <br />
Hệ thống MakerDAO:</p>
<ul>
  <li>DAI: stablecoin (giá: 0.99 ~ 1.01 USD)</li>
  <li>MKR:
    <ul>
      <li>ai cũng có thể mua để kiếm lãi.</li>
      <li>Sử dụng để quản trị, ổn định giá DAI trong trường hợp khẩn cấp.</li>
    </ul>
  </li>
</ul>

<h3 id="đúc-dai">Đúc DAI</h3>
<p>Giả sử: A muốn trả B bằng DAI nhưng A chỉ có 1 ETH. A sẽ tạo 1 vault trên MakerDAO contract:</p>
<ul>
  <li>1 wallet: tài sản mà A kiểm soát.</li>
  <li>1 vault: tài sản mà A khoá để vay DAI.</li>
</ul>

<p>Ta có:</p>
<ul>
  <li>Ban đầu, A có: 1ETH, 0DAI trong wallet, 0ETH, 0DAI trong vault.</li>
  <li>Khi A khoá 1 ETH vào vault: trong wallet sẽ không còn ETH, trong vault có 1ETH</li>
  <li>Việc khoá ETH xem như một cách thế chấp để vay DAI. Vì số lượng thế chấp = 130% số lượng tối đa có thể vay, nên khi A thế chấp 1 ETH (~3000USD) thì chỉ có thể vay tối đa 2300 DAI.</li>
  <li>Do đó, trong wallet A có 2300DAI, còn vault: 1ETH, -2300DAI.</li>
  <li>A trả cho B bằng DAI, và có thể trả nợ cho vault để lấy lại 1 ETH.</li>
</ul>

<h3 id="stabilization">Stabilization</h3>
<p>A khi thế chấp ETH và vay DAI, phải trả lãi: Phí ổn định. Hầu hết các phí đều đưa cho DAI holders (thông qua DSR), một số còn lại đưa cho MKR holders.</p>

<p><strong> The DAI saving rate (DSR)</strong> <br />
Bất kì ai giữ DAI có thể khoá DAI của mình trong MakerDAO contract. DSR là tỉ lệ lãi từ DAI đã khoá ở trên contract. Users có thể rút DAI ra từ contract bất cứ lúc nào.</p>

<p><strong> Cơ chế ổn định: </strong> <br /></p>
<ul>
  <li>DAI có giá trị &lt; 1$  ⇒ tăng phí ổn định và DSR:
    <ul>
      <li>Người đúc DAI được khuyến khích hoàn trả món nợ đã vay sớm vì lãi đang tăng</li>
      <li>Khuyến khích DAI holders gửi nhiều DAI vào contract</li>
      <li>Từ đó giúp giảm nguồnn cùng DAI, giúp DAI tăng giá</li>
    </ul>
  </li>
  <li>DAI có giá trị &gt; 1$  ⇒ giảm phí ổn định và DSR.</li>
</ul>

<h3 id="thanh-toán">Thanh toán</h3>
<p>Nếu vault debt vượt quá 130% (do lãi), thì tài sản thế chấp sẽ được bán đấu giá. (Tiền lãi - phí) sẽ được trả nợ vault cho A đến khi đạt dưới 130%.</p>

<h2 id="nfts">NFTs</h2>
<p>NFTs là:</p>
<ul>
  <li>Quyền sở hữu token của 1 tài sản kĩ thuật số (như Digital Artwork, vitual games item,…).</li>
  <li>Không thể có NFT nào giống nhau, nên không thể trao đổi lẫn nhau.</li>
  <li>Được xác định bởi lịch sử, mức độ tiện ích, tầm quan trọng,…</li>
</ul>

<p>NFTs được quản lý dưới blockchain vì:</p>
<ul>
  <li>Blockchain đảm bảo quyền sở hữu dài hạn cho đến khi bán.</li>
  <li>Cung cấp một hồ sơ đáng tin cậy về xuất xứ (chống giả mạo).</li>
</ul>

<h3 id="sở-hữu-tài-sản-kĩ-thuật-số">Sở hữu tài sản kĩ thuật số</h3>
<p>NFTs hoạt động như một chứng thư pháp lý:</p>
<ul>
  <li>Có thể chuyển quyền sở hữu từ bên này sang bên khác</li>
  <li>Quyền sỏ hữu thể hiện tình trạng sở hữu tài sản, cấp quyền hợp pháp,…</li>
</ul>

<h3 id="nhận-nfts-như-thế-nào">Nhận NFTs như thế nào</h3>
<p>Có 2 cách chính là tìm người sở hữu và mua từ học, hoặc lên thị trường và mua.</p>

<h3 id="thị-trường-nft">Thị trường NFT</h3>
<p>Được xây dựng như một tập các smartcontract, thành một hệ thống tài sản và trao đổi. NFT mang lại sự sở hữu đích thực trên Internet, kích hoạt thương mại kĩ thuật số,… Ví dụ: một số NFT đặc biệt mang lại cho người dùng sự truy cập vào một số IP, trang trên Internet.</p>

<h3 id="nft-cost-issue">NFT cost issue:</h3>
<p>Đa phần các NFT đều có giá cao, do đó muốn sở hữu thì có thể thuê hoặc tiết kiệm. Sẽ khó bắt đầu kinh doanh NFT nếu không có tiền mặt hoặc nguồn cung cấp đủ lớn.</p>

<p>Một số dịch vụ dựa trên NFTs như: Gameing guild (các item trong game: NFTs), EveryRealm (Bất động sản ảo), Credit Provider,…</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Stable coin là 1 loại tiền điện tử được tạo để giao dịch với một giá trị không đổi. Mục đích sinh ra Stablecoin là tích hợp tiền tệ trên thế giới thật vào các ứng dụng trên chuỗi và cho phép những người không thể có USD nắm giữ và giao dịch 1 tài sản tương đương.]]></summary></entry><entry><title type="html">Cơ chế Ethereum</title><link href="http://localhost:4000/blog/2023/07/23/ethereum-mechanics" rel="alternate" type="text/html" title="Cơ chế Ethereum" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/ethereum-mechanics</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/ethereum-mechanics"><![CDATA[<p>Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội</p>

<h3 id="so-sánh-chung">So sánh chung</h3>
<p>Bitcoin như một máy chuyển trạng thái. Bitcoin rule: S x I ⇾ S, với tập S là các trạng thái, I là tập tất cả các input. Còn với Ethereum, hàm chuyển trạng thái của nó sẽ phong phú hơn nhiều, và mỗi lần chuyển đổi thì sẽ thực hiện toàn bộ chương trình.</p>

<p>Ethereum hỗ trợ các DApp, với Program code được lưu trữ trên blockchain, khi chạy cũng sẽ thay đổi các trạng thái. Các block thì sẽ có khoảng 150 Tx, và các Block Proposer sẽ nhận Tx fee cho block và các phần thưởng khác khi tạo khối thành công.</p>

<p>Ngoài ra, ta đã biết rằng khi các block được proposer trong consensus layer (các beacon block, nên còn được gọi là beacon chain), các node gửi các Tx lên cho execution client hay còn gọi là compute layer để cập nhập các trạng thái (update world state).</p>
<h2 id="compute-layer">Compute layer</h2>
<p>World state: tập hợp các tài khoản được xác định bởi các địa chỉ 32 byte (Các thông tin như địa chỉ, số dư,..)</p>

<p>Có 2 loại tài khoản:</p>
<ul>
  <li>Owned account: Điều khiển bởi các cặp (Pk, Sk), hay là tài khoản của người dùng.</li>
  <li>Contracts: Điều khiển bởi code, được tạo lúc tài khoản được tạo, không thể thay đổi.</li>
</ul>

<p>Các dữ liệu cần thiết với mỗi account:</p>

<table>
  <thead>
    <tr>
      <th>Account Data</th>
      <th>Owned</th>
      <th>Contracts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>address(tính)</td>
      <td>H(Pk)</td>
      <td>H(CreatorAdd, CreatorNonce)</td>
    </tr>
    <tr>
      <td>storage root</td>
      <td>Không</td>
      <td>StorageRoot</td>
    </tr>
    <tr>
      <td>code</td>
      <td>không</td>
      <td>CodeHash</td>
    </tr>
    <tr>
      <td>balance</td>
      <td>balance</td>
      <td>balance</td>
    </tr>
    <tr>
      <td>nonce</td>
      <td>nonce</td>
      <td>nonce</td>
    </tr>
  </tbody>
</table>

<p>Trong đó, nonce là số Tx mà acount đã thực hành, tính bằng (#Tx sent) + (#accounts created). Số nonce được dùng để chống replay và khi tạo mới thì luôn bằng 0 (với contract).  Các contract có thể bị ghi đè code, nhưng chỉ khi contract cũ đã SELFDESTRUCT.</p>

<p>Mỗi contract có 1 mảng lưu trữ liên quan gồm 2^256 phần tử, mỗi phần tử là 32 bytes. Và storage root là Merkle Patricia hash của mảng.</p>

<h3 id="chuyển-trạng-thái">Chuyển trạng thái</h3>
<h4 id="tx">Tx</h4>
<ul>
  <li>Được kí bởi người tạo.</li>
  <li>To: nếu = 0 là tạo account mới, code = (init, body). Còn lại là 32-bytes địa chỉ và data (những thứ mà contract gọi và các đối số).</li>
  <li>From: Địa chỉ khởi tạo và chữ kí vào Tx</li>
  <li>Value: số Ethereum được gửi.</li>
  <li>Tx fees: gasLimit, maxFee, maxPriorityFee (Sẽ nói rõ hơn ở phần sau).</li>
  <li>Nonce: Khớp với nonce hiện tại của người gửi, tránh việc replay Tx.</li>
  <li>Chain-id: đảm bảo giao dịch gửi đúng chuỗi (không thể dùng giao dịch testnet lên mainnet).</li>
</ul>

<h4 id="các-loại-tx">Các loại Tx</h4>
<ul>
  <li>owned ⇾ owned: chuyển ETH giữa các user</li>
  <li>owned ⇾ contract: gọi contract với ETH &amp; data</li>
</ul>

<h4 id="messages">Messages</h4>
<p>Là các Tx ảo được contract tạo ra, nó không có Signature (vì contract không có). Có 2 loại là:</p>
<ul>
  <li>contract ⇾ onwed: contract gửi tiền cho user</li>
  <li>contract ⇾ contract: contract gọi contract khác.</li>
</ul>

<h3 id="ethereum-block">Ethereum block</h3>
<p>Khác với Block của Bitcoin, Block Header của Ethereum có nhiều loại dữ liệu hơn, một số chính như:</p>
<ul>
  <li>Consensus data: các dữ liệu như Proposer Id, Previous hash, vote,…</li>
  <li>Address: Nơi mà gas fee được chuyển đến</li>
  <li>World state root: Merkle Patricia Tree Hash của tất cả các tài khoản</li>
  <li>Tx root: Merkle Tree Hash của Tx</li>
  <li>Tx receipt root: Merkle Hash của các log message</li>
  <li>Gas used: Sử dụng để điều chỉnh giá gas (ở phần sau).</li>
</ul>

<h3 id="evm-mechanics">EVM mechanics</h3>
<p>EVM là môi trường thực thi (execution). Các contract được viết bằng solidity, sau đó sẽ được compile thành EVM bytecode và được các validator sử dụng để chạy các contract. <br />
EVM hoạt động như một [Stack Machine] (https://en.wikipedia.org/wiki/Stack_machine) với lệnh JUMP (Các program sẽ bị huỷ nếu quá stack, proposer giữ lại gas).</p>

<h3 id="gas">Gas</h3>
<p>Gas được xem như là nguyên liệu của Ethereum, là khoản phí cần trả để thực hiện các giao dịch hay hoạt động tương tác với smartcontract. Mọi chỉ thị đều tốn gas, giúp ngăn việc gửi Tx có nhiều bước (tốn nhiều tiền hơn). Các Proposer có thể chọn các Tx từ mempool có phí gas cao để tối đa hoá thu nhập.</p>

<h4 id="gas-calculation">Gas calculation:</h4>
<p>Mỗi block có:</p>
<ul>
  <li>baseFee: gasPrice nhỏ nhất cho tất cả Tx trong block. BaseFee dựa vào tổng số gas ở block trước (Gas used ở header), nếu gasUsed là giới hạn (30M) thì baseFee tăng 12.5%, nếu block trước trống thì giảm 12.5%. Còn lại thì giữ nguyên.</li>
  <li>gasLimit: tổng gas cho phép với Tx</li>
  <li>maxFee: giá gas tối đa cho phép</li>
  <li>maxPriorityFee: ‘tips’ tối đa cho Proposer.</li>
</ul>

<p>GasPrice = min(maxFee, baseFee + maxPriorityFee) <br />
MaxTxFee = gasLimit x gasPice <br />
<strong> Cụ thể </strong></p>
<ul>
  <li>nếu gasPrice &lt; baseFee: dừng</li>
  <li>nếu MaxTxFee &gt; sender.balance: dừng</li>
  <li>trừ MaxTxFee khỏi sender.balance</li>
  <li>Đặt Gas = gasLimit</li>
  <li>Chạy Tx, trừ gas từ Gas với mỗi Tx. Nếu Gas &lt; 0 thì dừng, Proposer giữ gasLimit * gasPrice.</li>
  <li>Xong xuôi, trả lại Gas x gasPrice cho sender</li>
  <li>gasUsed = gasLimit - Gas. BURN gasUsed x baseFee và gửi gasUsed x (GasPrice - baseFee) cho block proposer.</li>
</ul>

<p>ETH bị BURN vì giúp giảm lạm phát, tăng tính khan hiếm, có lợi cho nhà đầu tư, chặn các proposer tạo ra các Tx giả, không khuyến khích các thoả thuận ngoài chuỗi.</p>

<h2 id="kết-luận">Kết luận</h2>
<p>Ở trên là toàn bộ hiểu biết của mình về cơ chế Ethereum.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Mặc dù bitcoin được ra đời từ rất sớm và được sử dụng cho đến hiện tại, nó vẫn chứa nhiều nhược điểm. Phần chính là các ScriptPk của UTXO không thể thực hiện các quy tắc phức tạp về tài sản. Ví dụ khi muốn đưa ra giới hạn lượng BTC sử dụng trong 1 ngày là 2BTC, không thể làm với UTXO Script được. Do đó, Ethereum ra đời với nhiều ưu điểm vượt trội]]></summary></entry><entry><title type="html">Proof Of Stake</title><link href="http://localhost:4000/blog/2023/07/23/proof-of-stake" rel="alternate" type="text/html" title="Proof Of Stake" /><published>2023-07-23T00:00:00+07:00</published><updated>2023-07-23T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/23/proof-of-stake</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/23/proof-of-stake"><![CDATA[<p>Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.</p>

<h3 id="accountable-safety">Accountable Safety</h3>
<p>Một giao thức với resilence là n/3 khi giao thức đó an toàn nếu nó có ít hơn n/3 Adverserial node (Ví dụ streamlet). <br />
Một giao thức với Accountable Safety resilence n/3 là giao thức:</p>
<ul>
  <li>An toàn nếu ít hơn Adverserial node.</li>
  <li>Nếu vi phạm safety, thì những người giám sát (các node không phải người được chọn để đề xuất khối) có thể xác định rõ các node vi phạm.</li>
  <li>Không có cáo buộc sai với các node trung thực.</li>
</ul>

<h3 id="finality-và-dynamic-availability">Finality và Dynamic availability</h3>
<p>Gọi một giao thức là finality nếu nó duy trì safety trong thời gian không đồng bộ (trước GST). Ở các giao thức này, Tx được finalize nhanh hơn confirm trong bitcoin (60 phút). <br />
Gọi một giao thức là Dynamic availability nếu giao thức đó có thể tiếp tục confirm các giao dịch ngay cả khi nhiều node offline.</p>

<p>Không có giao thức SMR nào đảm bảo cung cấp cả 2. Do đó, một cách giải quyết là sử dụng Nested chains.</p>

<h3 id="nested-chains">Nested chains</h3>
<ul>
  <li>Available chain được xác định bởi giao thức Π_ava, thoả mãn Dynamic availability (VD: Nakamoto consensus).</li>
  <li>Finalized chain được xác định bởi giao thức checkpoint Π_fin thoả mãn security dưới mạng đồng bộ 1 phần.</li>
  <li>Chuỗi confirm bởi Π_ava là available chain.</li>
  <li>Π_fin kiểm tra các block trong availbale chain.</li>
  <li>Tiền tố của checkpoint cuối cùng tạo thành finalized chain. Tương đương với Finalized chain là prefix của available. Chuỗi này safe dưới mạng bất đồng bộ</li>
  <li>Các block của available chain luôn extend từ điểm checkpoint cuối cùng.</li>
</ul>

<p>Minh hoạ: hình ảnh</p>

<h2 id="proof-of-stake">Proof of Stake</h2>
<h3 id="tổng-quan">Tổng quan:</h3>
<ul>
  <li>Trong giao thức Pos, các nodes khoá (Stake) tiền của họ trong giao thức để đủ điều kiện tham gia consensus.</li>
  <li>Càng nhiều coin được stake bởi 1 node thì khả năng cao node đó được chọn làm validator. Vì thuật toán lựa chọn validator là giả ngẫu nhiên.</li>
  <li>Nếu node bị bắt quả tang thực hiện 1 hành động bất lợi (xác thực giao dịch sai) thì node đó sẽ bị burn số tiền đã stake và không thể tham gia vào quá trình đề xuất khối tiếp theo. (Slashing).</li>
</ul>

<p>Do đó, trong PoS, nodes sẽ có trách nhiệm trong cách hành động của mình. PoS giúp thay đổi cơ chế block được verify. Ngoài ra, để trở thành validator, các node phải có điều kiện (ví dụ: có ít nhất 32 ETH,..), sau khi đóng 1 khối, khối đó sẽ được các validator khác validate theo nhiều method khác nhau tuỳ vào blockchain.</p>

<h3 id="cụ-thể-với-ethereum-20">Cụ thể với Ethereum 2.0</h3>

<h4 id="chọn-validator-và-block-proposer">Chọn Validator và Block Proposer</h4>
<p>Để thành một validator, phải gửi ít nhất 32 ETH vào contract và chạy 3 phần mềm riêng biệt (sẽ giới thiệu ở sau) và tham gia hàng đợi. Thời gian của blocks chia thành các slot: 12s, epoch: 32 slot. Sau khi được active, validator đó sẽ tham ra vào quá trình phê duyệt. 1 validator ngẫu nhiên sẽ được chọn để xác thực giao dịch và đề xuất khối ở mỗi slot (Block proposer). Số còn lại sẽ làm giám sát để phê duyệt và kiểm tra xem validator đó có gian lận không.</p>

<p>Chọn Block Proposer quá trình giả ngẫu nhiên gồm nhiều yêu tố như staking age, số tiền stake,… Ở đây, mình sẽ giới thiệu 2 phương pháp lựa chọn là:</p>
<ul>
  <li><strong> Randomize block selection: </strong> lựa chọn bằng cách tìm kiếm nodes có sự kết hợp của hash value thấp nhất và stake cao nhất. Vì size của các stakes là công khai nên có thể dự đoán được.</li>
  <li><strong> Coin Age Selection: </strong> là phương thức chọn các nodes dựa vào khoảng thời gian stake. Coin Age được tính bằng: số ngày đặt cược x số lượng coin. Khi một node forge một block, coin age của nó được cài về 0.</li>
</ul>

<h4 id="quy-trình-xác-thực">Quy trình xác thực</h4>
<p>Khi một user tạo Tx và submit lên Ethereum, nó sẽ được kiểm tra tính hợp lệ (Ví dụ đảm bảo số tiền, key đúng,…) sau đó được đưa đến mempool và phát tán nó đến các node khác. <br />
Một node được chọn làm Block Proposer để đề xuất khối ở slot này, có trách nhiệm đóng và phát tán block vào chuỗi và cập nhập trạng thái. Nodes chạy 3 phần mềm:</p>
<ul>
  <li>Execution client: gộp các Txs từ mempool thành “execution payload” và chạy nó ở local để tạo ra sự thay đổi trạng thái. Thông tin này được chuyển đến consensus client</li>
  <li>Consensus client: đóng gói payload thành 1 phần của “beacon block” (gồm payload, slashing,…) cho phép mạng thống nhất trình tự về các khối.</li>
  <li>Validator client: Các node nhận được beacon block qua tầng gossip network. Sau đó chuyển đến Execution client của nó để chạy lại, nhằm chắc chắn trạng thái là đúng. Sau đóm Validator client sẽ chứng thực khối đó hợp lệ và là khối tiếp theo trong góc nhìn của chuỗi (available chain). Khối cũng được thêm vào cơ sở dữ liệu local của các node.</li>
</ul>

<h4 id="finality">Finality</h4>
<p>Như đã nói ở trên, các block của available chain luôn extend từ điểm checkpoint cuối cùng. Checkpoint là các block đầu tiên ở mỗi epoch. Các validators có thể vote cho cặp checkpoint (1 epoch), nếu ít nhất 2/3 vote cho nó, cặp checkpoint này sẽ được cập nhập, và các block nằm giữa sẽ được cập nhập thành finalized chain. Nếu chuỗi không thể finalized trong nhiều hơn 4 epoch liên tục, stake ETH từ các validator chống lại đa số sẽ bị biến mất, cho phép đa số chiếm hơn 2/3 và finalized chuỗi.</p>

<h2 id="lời-kết">Lời kết</h2>
<p>Ở trên là cách hoạt động cơ bản của POS. Mọi người có thể xem thêm các thông tin về POS trong Ethereum tại <a href="https://ethereum.org/vi/developers/docs/consensus-mechanisms/pos/">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, mình sẽ giới thiệu một cơ chế đồng thuận đang được sử dụng rất nhiều trong các blockchain hiện nay, đó là Proof of Stake.]]></summary></entry><entry><title type="html">Đồng thuận trên mạng</title><link href="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang" rel="alternate" type="text/html" title="Đồng thuận trên mạng" /><published>2023-07-22T00:00:00+07:00</published><updated>2023-07-22T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/22/dong-thuan-tren-mang"><![CDATA[<p>Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.</p>

<h2 id="bitcoin-mining">Bitcoin Mining</h2>
<p>Bitcoin chọn các nodes tham gia vào giao thức bằng các sử dụng POW, giải bài toán tìm số nonce (xem chi tiết <a href="http://127.0.0.1:4000/blog/2023/07/20/cau-tao-block-va-pow">tại</a>). 
Bitcoin sử dụng Nakamoto consensus: <br /> 
<strong> Quy tắc đề xuất: </strong> ở thời điểm nào, mỗi miner trung thực mở rộng chuỗi nặng nhất (với độ khó cao nhất).
<strong> Quy tắc confirmation: </strong> Miner confirm 1 block (với tiền tố của nó) mà ở độ sâu k trong chuỗi nó nhìn được.</p>
<ul>
  <li>Ví dụ trong thực tế: k = 6.</li>
  <li>Miner và client chấp nhận các Tx ở block cuối cùng được confirm và tiền tố của nó như là log.</li>
  <li>Leader được chọn bởi POW.</li>
</ul>

<p>So sánh giữa Bitcoin và Streamlet /// ảnh <br /></p>
<ul>
  <li>Streamlet thì không dynamic available: Nó sẽ không đảm bảo liveness nếu n/3 hoặc hơn các nodes offline.</li>
  <li>Bitcoin thì dynamic available: tiếp tục confirm Tx khi miningpower offline. <br /></li>
</ul>

<h2 id="consensus-ở-internet">Consensus ở Internet</h2>
<p>Các nodes tham gia mở, tức là các adversary có thể tạo nhiều node và người tham gia trung thực có thể online hoặc offline và đi tuỳ ý. Do đó, mục tiêu đặt ra là phải hạn chế sự tham gia của Adversary, đồng thời duy trì dynamic available của giao thức.</p>

<h2 id="security">Security</h2>
<p>Bitcoin đảm bảo an toàn dưới mạng đồng bộ, với tỉ lệ mining power do Adversary kiểm soát 𝜷 &lt; 1/2</p>

<h3 id="nakamotos-private-attack-𝜷--12">Nakamoto’s Private Attack: 𝜷 ≥ 1/2</h3>
<p>Khi adversay đào block mới, nhưng không công bố. Các miner trung thực tiếp tục đào mà không biết về các block ẩn này. Khi adversary công bố chuỗi đó (đã tạo đủ block), chuỗi đó trở thành chuỗi dài hơn chuỗi mà miners trung thực đào được (vì 𝜷 ≥ 1/2), các block đào bởi các miner trung thực sẽ bị bỏ.</p>
<h3 id="forking">Forking</h3>
<p>Vì Network delay, các honest blocks ở cùng 1 độ cao. Do đó, tỉ lệ phát triển các khối honest sẽ chậm hơn so với 1 - 𝜷. Do đó, Adversary sẽ thành công nếu 𝜷 ≥ (1 - 𝜷) / 2 (Trường hợp chỉ có 2 chuỗi fork).</p>
<h3 id="security-1">Security</h3>
<p>Nếu 𝜷 &lt; 1/2, tồn tại tỉ lệ Mining đủ nhỏ 𝜆(Δ,𝛽) = 𝜆A + 𝜆H mà Bitcoin thoả mãn security với tỉ lệ lỗi chấp nhận là 𝑒^(−Ω(𝑘)) dưới mạng đồng bộ. Đây là xác xuất lỗi với comfirmation. Đây chính là lý do sau 10 phút mới tạo ra khối mới chứ không phải là 1 giây.</p>

<h4 id="chứng-minh">Chứng minh</h4>
<p>Nhận thấy, với các khối trung thực được tạo, vẫn có thể tạo ra fork vì khối sau được tạo ra quá gần khối trước (&lt; Δ). Lúc này, khối tạo sau được gọi là Tailgater. Ngược lại, nếu khối được tạo ở thời điểm t, và không tồn tại khối nào được tạo trong khoảng thời gian từ t - Δ đến t, thì khối đó được gọi là Non-Tailgater. Các khối Non-Tailgater thì có độ cao riêng biệt nhau.</p>

<p>Giờ, ta cần tìm tỉ lệ các khối trung thực là Tailgater hoặc Non-Tailgater. Xem thời gian tạo các khối là biến ngẫu nhiên Poisson, thì khoảng thời gian T giữa 2 khối tuân theo phân bố mũ. <br /> 
Gọi mining rate là λ (1/ minutes). Với Bitcoin λ = 1/10.<br />
Theo phân bố mũ, xác suất để T lớn hơn s bất kì là: P[T &gt; s] = 𝑒^(-λs). Suy ra, nếu s = Δ thì tỉ lệ honest block tạo ra là Non-Tailgater là g = P[T &gt; Δ] =  𝑒^(-λΔ), Tailgater là 1 - g.</p>

<p>Ta thấy, các Non-tailgater block tăng với tỉ lệ: gλ, các block này có height khác nhau, vì thế chuỗi dài nhất cũng tăng ít nhất với tỉ lệ này. =&gt; liveness.</p>

<p>Với Safety, ta cần thêm các khái niệm sau:</p>
<ul>
  <li>Block B được đào ở thời gian t, nếu không có honest block nào khác được đào từ t−Δ đến t+Δ thì B gọi là loner. Do đó, loner là block duy nhất ở độ cao đó. <br />
Để vi phạm safety, cần phải có hai chuỗi khác nhau hơn k khối, cả hai đều được thông qua bởi các node trung thực. Điều này tương đương với các Adversary phải khai thác các khối nhanh hơn các khối loner được tạo ra. Gọi tỉ lệ mine của Adversary là 𝜷. Tỉ lệ mine loner là g * g * λ. <br /> Do đó, Nakamoto đảm bảo security nếu g * g * λ &gt; 𝜷.</li>
</ul>

<h2 id="kêt-luận">Kêt luận</h2>
<p>Nếu mọi người muốn xem chi tiết về cách chứng minh, hãy truy cập vào <a href="https://eprint.iacr.org/2019/943.pdf">đây</a>.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài trước, ta đã biết rằng các node sẽ tham gia vào giao thức có thể là Adversary và có thể gây hại cho blockchain. Vậy làm cách nào để chọn các node tham gia vào consensus.]]></summary></entry><entry><title type="html">Cơ bản về đồng thuận</title><link href="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus" rel="alternate" type="text/html" title="Cơ bản về đồng thuận" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/fundamentals-of-consensus"><![CDATA[<p>Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. 
Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.</p>

<h2 id="tác-hại-của-adversary">Tác hại của Adversary</h2>
<p>Có thể gây:</p>
<ul>
  <li>Lỗi crash: Nếu các nodes này không gửi và nhận các msg (message)</li>
  <li>Lỗi bỏ sót: Nếu các nodes này chọn hoặc bỏ qua các msg</li>
  <li>Lỗi Byzantine: Các node sai có thể đi lệch khỏi giao thức.</li>
</ul>

<p>Có 2 loại adversary</p>
<ul>
  <li>Static: phá huỷ node mà nó chọn trước khi bắt đầu giao thức.</li>
  <li>Adaptive: có thể phá huỷ các node khi giao thức xảy ra.
<br />
Giới hạn sức mạnh của adversary là số node:  f. Ví dụ: f &lt; n/2, f &lt; n/3.</li>
</ul>

<h2 id="các-nodes-giao-tiếp-với-nhau">Các nodes giao tiếp với nhau</h2>
<p>Các nodes gửi các tin nhắn (message) cho nhau trong giao thức. Giả sử một node adversary đang điều khiển việc gửi tin nhắn:</p>
<ul>
  <li>Trong một mạng đồng bộ: Adversary phải chuyển tin nhắn bất kì trong thời gian Δ giây (Δ đã biết).</li>
  <li>Trong mạng không đồng bộ: Adversary có thể hoãn msg trong 1 khoảng thời gian hữu hạn, nhưng cuối cùng vẫn phải chuyển.</li>
  <li>Trong mạng đồng bộ 1 phần: tồn tại 1 sự kiện gọi là GST mà: Một msg gửi bởi 1 honest node ở thời gian t sẽ đến với người nhận trong khoảng thời gian:  Δ + Max(t, GST). 
<br />
Điều này tương đương với mạng sẽ không đồng bộ cho tới GST, sau đó sẽ đồng bộ</li>
</ul>

<h3 id="state-machine-replication-smr">State Machine Replication (SMR)</h3>
<p>Là phương pháp chung để triển khai dịch vụ chịu lỗi bằng việc sao chép máy chủ và điều phối tương tác của máy client với bản sao đó. Nó cung cấp framework để hiểu và thiết kết giao thức quản lý sao chép.</p>

<p>SMR gồm 2 phần:</p>
<ul>
  <li>Replicas: Nhận Tx, chạy giao thức SMR và xác định log. Các Log(Ledger) là chuỗi Tx thứ tự tuyến tính.</li>
  <li>Client: Giao tiếp với replicas để nhận log (ví dụ: wallet).
Các wallet không chạy giao thức SMR và cũng không giao tiếp với nhau. Nó hỏi các replicas về các log và chọn kết quả được nhiều replicas gửi về nhất.</li>
</ul>

<h3 id="bảo-mật-cho-smr">Bảo mật cho SMR</h3>
<p>Gọi A ≼ B khi A là tiền tố của B. Ví dụ: A = Tx1Tx2Tx3, B = Tx1Tx2Tx3Tx5Tx6 thì A là tiền tố của B.<br />
Gọi LOG(i, t) là log đưa ra bởi client i ở thời điểm t. Một giao thức SMR là an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  LOG(i, t) ≼ LOG(j, s) hoặc LOG(j, s) ≼ LOG(i, t) hoặc cả 2. =&gt; không thể xảy ra Double Spent</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ LOG(i, s).</li>
</ul>

<h2 id="giao-thức-blockchain">Giao thức Blockchain</h2>
<p>Các Txs được đóng thành các block để tăng thông lượng. Gọi CH(i, t) là chuỗi được accept bởi client i tại thời gian t. Giao thức blockchain đảm bảo an toàn nếu thoả mãn:</p>
<ul>
  <li>Safety: Với client i và j, ở 2 thời gian t và s: <br />
  CH(i, t) ≼ CH(j, s) hoặc CH(j, s) ≼ CH(i, t) hoặc cả 2</li>
  <li>Liveness: với Tx là input của 1 honest replica ở thời điểm t, =&gt; với mọi i ở thời điểm s ≥ t thì: <br />
Tx ∈ CH(i, s).</li>
</ul>

<p>Mong muốn giao thức phải đảm bảo an toàn dưới môi trường bán đồng bộ. Theo DLS(1988), nếu f ≥ n/3 thì giao thức SMR không thể đảm bảo an toàn. Bây giờ với f &lt; n/3, ta sẽ chứng minh là giao thức này an toàn.</p>

<h2 id="chứng-minh">Chứng minh</h2>
<p>Thời gian chia thành các epoch, mỗi epoch là 2Δ giây. Có n replicas cố định, mỗi epoch e được chỉ định 1 leader Le bởi hàm Hash.</p>
<h3 id="baby-streamlet">Baby streamlet</h3>
<p><strong>Đề xuất khối: </strong> Ở đầu mỗi epoch, Le xác định chuỗi dài nhất nó từng thấy cho đến nay và sẽ đề xuất 1 khối liền sau chuỗi đó. <bn>
<strong>Finalization: </strong> 1 replica finalizes block (và tiền tố của nó) ở đầu chuỗi. Nếu có nhiều block như thế, chọn block có epoch nhỏ nhất.<br />
Tuy nhiên, có một nhược điểm là nếu Leader là adversary và network chưa đồng bộ, thì Adversary có thể gửi thông báo các Block cho 1 user bất kì, nhưng thông báo chưa tới các user còn lại cho tới sau GST. 
/// hình minh hoạ</bn></p>

<h3 id="teen-streamlet">Teen streamlet</h3>
<p>Votes: 1 vote trên block bởi replica là chữ kí của nó trên block. <br />
Notarization: 1 block được xem là Notarized dưới góc nhìn của replica nếu block đó có hơn 2n/3 chữ kí từ các replica khác.<br />
<strong>Đề xuất khối: </strong> Đầu mõi epoch e, Le xác định chuỗi Notarized dài nhất và đề xuất khối sau chuỗi Notarized này.<br />
<strong> Vote: </strong> ∆ giây ở epoch e,mỗi replica vote cho đề xuất hợp lệ đầu tiên dưới góc nhìn của Le (mở rộng chuỗi dài nhất theo góc nhìn của nó).<br />
<strong>Finalization: </strong>  1 replica finalize 1 block và tiền tố của nó sau khi thấy khối được notarized.</p>

<p>Ví dụ: /// hình ảnh <br />
Chứng minh: với f &lt; n/3, với mỗi epoch e, chỉ có tối đa 1 notarized block với epoch là e trong góc nhìn của bất kì replica trung thực nào. <br />
Giả sử 2 khối cùng epoch e là B và B’. Vì f &lt; n/3 nên tồn tại replica vote cho cả B, B’. Mà số vote của B và B’ lớn hơn 2/3 =&gt; số replica vote cho cả 2 là &gt; n/3. Đây là vô lý. Vậy khi network chưa đồng bộ, giao thức này đảm bảo an toàn.<br />
Với các block có epoch khác nhau, có thể cùng ở chung 1 độ cao. Gọi 2 block đó là B1 và B2. Ban đầu, ở B, adversarial đề xuất B1 cho 66 replica trung thực, nên B1 chưa được notarized (vì có 66 vote). Tiếp theo, B2 được đề xuất bởi 1 replica trung thực, và được notarized nhưng trong đó có 1 adversarial vote cho B1, nên B1 cũng được notarized. Từ đó dẫn đến vi phạm safety.</p>

<h3 id="streamlet">Streamlet</h3>
<p><strong>Finalization: </strong> Khi thấy 3 khối kề nhau trong chuỗi được notarized với epoch liên tiếp, thì client sẽ finalize block thứ 2 trong 3 block trên và tẩt cả tiền tố của nó.</p>

<p>Độ phức tạp giao tiếp là O(N^3) message cho mỗi block, vì mỗn honest replica chuyển tiếp các votes nó nhận từ các replica khác cho tất cả các replica.
Chứng minh tính an toàn:<br />
<strong> Safety: </strong> Giả sử có 2 block đang trong tình trạng confict ở epoch e và e’. Nếu: <br /></p>
<ul>
  <li>e = e’: không thể (đã chứng minh ở Teen Streamlet).<br /></li>
  <li>e &lt; e’: suy ra e+1 &lt; e’. Vì B3 được notarized nên có ít nhất S &gt; n/3 replica trung thực vote cho B3 tại e+1. Vậy S sẽ thấy B2 được notarized ở đầu epoch e+1, do đó, S sẽ không vote cho B’ vì B’ không mở rộng từ chuõi dài nhất. Mà S &gt; n/3 nên B’ không được notarized. <br /></li>
  <li>e &gt; e’: suy ra e-1 &gt; e’. Nếu B’ được notarized, có S &gt; n/3 replica trung thực vote cho nó tại epoch e’. Vậy S sẽ thấy B” được notarized ở đầu epoch e”, do đó S sẽ không vote cho B1. Tương tự, B1 không được notarized. Điều này trái với giả thiết.<br />
Hình Minh Hoạ: <br />
Vậy, Streamlet đảm bảo safety<br /></li>
</ul>

<p><strong> Liveness: </strong> Giả sử có 4 slot liên tiếp: e, e + 1, e + 2, e + 3 với leader trung thực sau GST. Ở cuối các slot này, client sẽ finalize block được đề xuất bởi các replica trung thực. Trong đó:</p>
<ul>
  <li>1 slot để undo các hành động của adversary. <br /></li>
  <li>3 slot để finalize block. <br />
Ngoài ra, đảm bảo không có 2 block liên tiếp nhau mà chưa được notarized.</li>
</ul>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ tìm hiểu về cách Bitcoin chống lại việc những nodes không trung thực tấn công vào mạng lưới. Những nodes không trung thực (Adversary) là những nodes gây hại, chúng có mục đích khiến Blockchain không còn minh bạch và nhẩt quán để dễ dàng thêm vào những giao dịch sai mà có lợi cho chúng.]]></summary></entry><entry><title type="html">Bitcoin Scripts và Ví</title><link href="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet" rel="alternate" type="text/html" title="Bitcoin Scripts và Ví" /><published>2023-07-21T00:00:00+07:00</published><updated>2023-07-21T00:00:00+07:00</updated><id>http://localhost:4000/blog/2023/07/21/bitcoin-scripts-and-wallet</id><content type="html" xml:base="http://localhost:4000/blog/2023/07/21/bitcoin-script-and-wallet"><![CDATA[<p>Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.</p>

<h3 id="một-số-lưu-ý">Một số lưu ý</h3>
<ul>
  <li>Các Tx sau khi thêm vào khối sẽ không thể bị xoá, do đó khi Tx nhầm thì sẽ bị khoá hoặc mất tiền.</li>
  <li>Các TxID là độc nhất, vì Input của chúng là độc nhất. Có trường hợp ngoại lệ là các Coinbase vì chúng không có input. Do đó có thể có trùng TxID. Vì vậy, người ta thường thêm Block Height và mỗi ScriptPk của coinbase.</li>
</ul>

<h2 id="ví-dụ-về-các-loại-bitcoin-scripts">Ví dụ về các loại Bitcoin Scripts</h2>
<h3 id="bảo-vệ-tài-sản-với-co-signatory">Bảo vệ tài sản với co-signatory</h3>
<p>addr = 2 - of - 2 (PkA, PkS) với PkS là của custody server.</p>

<h3 id="escrow-service">Escrow Service</h3>
<p>Giả định: A muốn mua balo từ B với giá 0.1 BTC, nhưng A chỉ có thể trả tiền khi balo đến, và không thể không trả. Do vậy, addr có dạng: 2-of-3 (PkA, PkB, PkJ).</p>

<p>Cách vận hành:</p>
<ul>
  <li>A thông báo cho B rằng muốn mua balo với giá 0.1 BTC</li>
  <li>A post 1 Tx 0.11 BTC đến addr trên (0.01BTC để đảm bảo A sẽ trả tiền cho B).</li>
  <li>B khi thấy Tx, gửi balo cho A</li>
  <li>Khi A nhận, gửi SigA trong Tx trên cho B</li>
  <li>B sẽ sử dụng SigA và SigB để lấy số tiền mà A gửi lên Addr.</li>
</ul>

<p>Nếu vi phạm xảy ra:</p>
<ul>
  <li>B không đưa balo, A sẽ lấy lại tiền với sự trợ giúp của Judge (PkJ).</li>
  <li>A không đưa SigA, B sẽ lấy tiền với sự giúp đỡ của Judge, A mất thêm 0.01BTC.</li>
</ul>

<h2 id="ví">Ví</h2>
<p>Ví giúp user tạo ra các cặp Pk- Sk, tạo ra và xác minh các Tx, đưa ra số dư mà user có.</p>

<h3 id="giúp-đơn-giản-hoá-xác-minh-thanh-toán">Giúp đơn giản hoá xác minh thanh toán</h3>
<p>Để xác minh một thanh toán đã thực hiện, ví thường tải các block headers. Sau đó, ví gửi lên server danh sách các địa chỉ mà ví đang nắm giữ. Sau đó, server sẽ gửi về ví các Tx liên quan đến địa chỉ và Merkle Proof của Tx đó. Từ đó giúp ví hiển thị đúng số dư và xác minh Tx.</p>

<h3 id="vấn-dề">Vấn dề</h3>
<ul>
  <li>Để giải quyết được yếu tố bảo mật, blockheader sẽ được tải từ 10 servers khác nhau hoặc từ 1 nodes tin cậy.</li>
  <li>Remote server có thể kiểm tra xem addr gửi lên có thuộc về ví hay không.</li>
</ul>

<h3 id="các-loại-ví">Các loại ví</h3>
<h4 id="hot-wallet">Hot wallet</h4>
<ul>
  <li>Dạng ví điện tử có kết nối Internet, có nhiều chức năng như lưu trữ, gửi nhận Tx, tokens,…</li>
  <li>Có thể truy cập từ các thiết bị Internet như máy tính, điện thoại,..</li>
  <li>Có thể bị hack hoặc xâm nhập bởi các hacker.</li>
</ul>

<h3 id="cold-wallet">Cold wallet</h3>
<ul>
  <li>Không cho phép kết nối Internet.</li>
  <li>Có thiết bị riêng cho cold wallet, thiết bị này phải được khởi động bất cứ khi nào sử dụng và người dùng phải sao chép vật lý dữ liệu từ online device sang offline và ngược lại.</li>
</ul>

<h2 id="kết-luận">Kết luận</h2>
<p>Có nhiều loại Bitcoin Script khác như CrossChain,… được sử dụng rất phổ biến ở hiện tại.</p>]]></content><author><name>vanhg</name></author><summary type="html"><![CDATA[Ở bài viết này, chúng ta sẽ đi sâu hơn về một số ví dụ của Bitcoin Script và các loại ví thường được sử dụng.]]></summary></entry></feed>